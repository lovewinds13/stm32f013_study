; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\logic_grammer.o --asm_dir=.\ --list_dir=.\ --depend=.\logic_grammer.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\App\inc -I..\Driver\inc -I..\Libraries\CMSIS\Core\inc -I..\Libraries\CMSIS\Device\inc -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\HalIterface\inc -I..\User\inc -I.\RTE\_Target_1 -IC:\Users\Administrator\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=529 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\logic_grammer.crf ..\App\src\logic_grammer.c]
                          THUMB

                          AREA ||i.Crc_B16||, CODE, READONLY, ALIGN=1

                  Crc_B16 PROC
;;;302    //--------------------------------------------------------------------------------------------------------
;;;303    uint16_t Crc_B16(uint8_t *Indata, uint16_t len, uint16_t CrcTmp)
000000  b5f0              PUSH     {r4-r7,lr}
;;;304    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;305    	uint16_t y = 0;
000008  2100              MOVS     r1,#0
;;;306    	uint16_t yy = 0;
00000a  468c              MOV      r12,r1
;;;307    	uint8_t x = 0;
00000c  2600              MOVS     r6,#0
;;;308    	uint32_t i = 0;
00000e  2200              MOVS     r2,#0
;;;309    	uint32_t j = 0;
000010  2700              MOVS     r7,#0
;;;310    
;;;311         y = ~CrcTmp & 0xffff;
000012  43e8              MVNS     r0,r5
000014  b281              UXTH     r1,r0
;;;312    	
;;;313    	for(i = 0; i < len; i++)
000016  bf00              NOP      
000018  e014              B        |L1.68|
                  |L1.26|
;;;314    	{
;;;315    		x = Indata[i];
00001a  5c9e              LDRB     r6,[r3,r2]
;;;316    		for (j = 0; j < 8; j++)
00001c  2700              MOVS     r7,#0
00001e  e00e              B        |L1.62|
                  |L1.32|
;;;317    		{
;;;318    			if (((y^x) & 1) !=0) 
000020  ea810006          EOR      r0,r1,r6
000024  f0000001          AND      r0,r0,#1
000028  b110              CBZ      r0,|L1.48|
;;;319    			{
;;;320    				yy= 0x8408;
00002a  f2484c08          MOV      r12,#0x8408
00002e  e001              B        |L1.52|
                  |L1.48|
;;;321    			}
;;;322    			else 
;;;323    			{
;;;324    				yy=0;
000030  f04f0c00          MOV      r12,#0
                  |L1.52|
;;;325    			}
;;;326    		x >>= 1;
000034  1076              ASRS     r6,r6,#1
;;;327    		y >>= 1;
000036  1049              ASRS     r1,r1,#1
;;;328    		y ^= yy;
000038  ea81010c          EOR      r1,r1,r12
00003c  1c7f              ADDS     r7,r7,#1              ;316
                  |L1.62|
00003e  2f08              CMP      r7,#8                 ;316
000040  d3ee              BCC      |L1.32|
000042  1c52              ADDS     r2,r2,#1              ;313
                  |L1.68|
000044  42a2              CMP      r2,r4                 ;313
000046  d3e8              BCC      |L1.26|
;;;329    		}
;;;330    	}
;;;331    	
;;;332    	return (~y & 0xffff);
000048  43c8              MVNS     r0,r1
00004a  b280              UXTH     r0,r0
;;;333    }
00004c  bdf0              POP      {r4-r7,pc}
;;;334    
                          ENDP


                          AREA ||i.My_Memcmp||, CODE, READONLY, ALIGN=1

                  My_Memcmp PROC
;;;121    //--------------------------------------------------------------------------------------------------------
;;;122    int My_Memcmp(void *str1, void *str2, int count)
000000  b570              PUSH     {r4-r6,lr}
;;;123    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4613              MOV      r3,r2
;;;124    	char *ptr1 = (char *)str1;
000008  4621              MOV      r1,r4
;;;125    	char *ptr2 = (char *)str2;
00000a  462a              MOV      r2,r5
;;;126    
;;;127    	if (!count)
00000c  b90b              CBNZ     r3,|L2.18|
;;;128    	{
;;;129    		return 0;
00000e  2000              MOVS     r0,#0
                  |L2.16|
;;;130    	}
;;;131    
;;;132    	while (count--)
;;;133    	{
;;;134    		if (*ptr1 == *ptr2)
;;;135    		{
;;;136    			ptr1 = ptr1 + 1;
;;;137    			ptr2 = ptr2 + 1;
;;;138    		}
;;;139    		else
;;;140    		{
;;;141    			return *ptr1 - *ptr2;
;;;142    		}
;;;143    	}
;;;144    	return *ptr1 - *ptr2;
;;;145    }
000010  bd70              POP      {r4-r6,pc}
                  |L2.18|
000012  e00a              B        |L2.42|
                  |L2.20|
000014  7808              LDRB     r0,[r1,#0]            ;134
000016  7816              LDRB     r6,[r2,#0]            ;134
000018  42b0              CMP      r0,r6                 ;134
00001a  d102              BNE      |L2.34|
00001c  1c49              ADDS     r1,r1,#1              ;136
00001e  1c52              ADDS     r2,r2,#1              ;137
000020  e003              B        |L2.42|
                  |L2.34|
000022  7808              LDRB     r0,[r1,#0]            ;141
000024  7816              LDRB     r6,[r2,#0]            ;141
000026  1b80              SUBS     r0,r0,r6              ;141
000028  e7f2              B        |L2.16|
                  |L2.42|
00002a  1e18              SUBS     r0,r3,#0              ;132
00002c  f1a30301          SUB      r3,r3,#1              ;132
000030  d1f0              BNE      |L2.20|
000032  7808              LDRB     r0,[r1,#0]            ;144
000034  7816              LDRB     r6,[r2,#0]            ;144
000036  1b80              SUBS     r0,r0,r6              ;144
000038  e7ea              B        |L2.16|
;;;146    
                          ENDP


                          AREA ||i.My_Memcpy||, CODE, READONLY, ALIGN=1

                  My_Memcpy PROC
;;;54     //--------------------------------------------------------------------------------------------------------
;;;55     void *My_Memcpy(void *dest, const void *src, unsigned int count)
000000  b570              PUSH     {r4-r6,lr}
;;;56     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4613              MOV      r3,r2
;;;57     	char *pdest = (char *)dest;
000008  4621              MOV      r1,r4
;;;58     	char *psrc = (char *)src;
00000a  462a              MOV      r2,r5
;;;59     
;;;60     	if (pdest == NULL || psrc == NULL)
00000c  b101              CBZ      r1,|L3.16|
00000e  b90a              CBNZ     r2,|L3.20|
                  |L3.16|
;;;61     	{
;;;62     		return NULL;
000010  2000              MOVS     r0,#0
                  |L3.18|
;;;63     	}
;;;64     
;;;65     	if (pdest == psrc)
;;;66     	{
;;;67     		return 0;
;;;68     	}
;;;69     
;;;70     	if (pdest > psrc)	//目的地址和源地址存在重叠的情况
;;;71     	{
;;;72     		while (count--)
;;;73     		{
;;;74     			*(pdest + count) = *(psrc + count);
;;;75     		}
;;;76     	}
;;;77     	else
;;;78     	{
;;;79     		while (count--)
;;;80     		{
;;;81     			*pdest++ = *psrc++;
;;;82     		}
;;;83     	}
;;;84     	return pdest;
;;;85     }
000012  bd70              POP      {r4-r6,pc}
                  |L3.20|
000014  4291              CMP      r1,r2                 ;65
000016  d101              BNE      |L3.28|
000018  2000              MOVS     r0,#0                 ;67
00001a  e7fa              B        |L3.18|
                  |L3.28|
00001c  4291              CMP      r1,r2                 ;70
00001e  d907              BLS      |L3.48|
000020  e001              B        |L3.38|
                  |L3.34|
000022  5cd0              LDRB     r0,[r2,r3]            ;74
000024  54c8              STRB     r0,[r1,r3]            ;74
                  |L3.38|
000026  1e18              SUBS     r0,r3,#0              ;72
000028  f1a30301          SUB      r3,r3,#1              ;72
00002c  d1f9              BNE      |L3.34|
00002e  e008              B        |L3.66|
                  |L3.48|
000030  e003              B        |L3.58|
                  |L3.50|
000032  f8120b01          LDRB     r0,[r2],#1            ;81
000036  f8010b01          STRB     r0,[r1],#1            ;81
                  |L3.58|
00003a  1e18              SUBS     r0,r3,#0              ;79
00003c  f1a30301          SUB      r3,r3,#1              ;79
000040  d1f7              BNE      |L3.50|
                  |L3.66|
000042  4608              MOV      r0,r1                 ;84
000044  e7e5              B        |L3.18|
;;;86     
                          ENDP


                          AREA ||i.My_Memset||, CODE, READONLY, ALIGN=1

                  My_Memset PROC
;;;97     //--------------------------------------------------------------------------------------------------------
;;;98     void *My_Memset(void *dest, int n, unsigned int len)
000000  b530              PUSH     {r4,r5,lr}
;;;99     {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;100    	if (dest == NULL)
000006  b90b              CBNZ     r3,|L4.12|
;;;101    		return NULL;
000008  2000              MOVS     r0,#0
                  |L4.10|
;;;102    	char *pdest = (char *)dest;
;;;103    	while (len--)
;;;104    	{
;;;105    		*pdest++ = n;
;;;106    	}
;;;107    
;;;108    	return dest;
;;;109    }
00000a  bd30              POP      {r4,r5,pc}
                  |L4.12|
00000c  4619              MOV      r1,r3                 ;102
00000e  e001              B        |L4.20|
                  |L4.16|
000010  f8014b01          STRB     r4,[r1],#1            ;105
                  |L4.20|
000014  1e10              SUBS     r0,r2,#0              ;103
000016  f1a20201          SUB      r2,r2,#1              ;103
00001a  d1f9              BNE      |L4.16|
00001c  4618              MOV      r0,r3                 ;108
00001e  e7f4              B        |L4.10|
;;;110    
                          ENDP


                          AREA ||i.My_Strcmp||, CODE, READONLY, ALIGN=1

                  My_Strcmp PROC
;;;204    //--------------------------------------------------------------------------------------------------------
;;;205    int My_Strcmp(const char *str1, const char *str2)
000000  4602              MOV      r2,r0
;;;206    {
;;;207    	if (str1 == NULL || str2 == NULL)
000002  b102              CBZ      r2,|L5.6|
000004  b909              CBNZ     r1,|L5.10|
                  |L5.6|
;;;208    	{
;;;209    		return NULL;
000006  2000              MOVS     r0,#0
                  |L5.8|
;;;210    	}
;;;211    	
;;;212    	while (*str1 == *str2)
;;;213    	{
;;;214    		str1++;
;;;215    		str2++;
;;;216    		
;;;217    		if (*str1 == '\0' || *str2 == '\0')
;;;218    		{
;;;219    			break;
;;;220    		}
;;;221    	}
;;;222    	
;;;223    	return *str1 - *str2;
;;;224    }
000008  4770              BX       lr
                  |L5.10|
00000a  e006              B        |L5.26|
                  |L5.12|
00000c  1c52              ADDS     r2,r2,#1              ;214
00000e  1c49              ADDS     r1,r1,#1              ;215
000010  7810              LDRB     r0,[r2,#0]            ;217
000012  b108              CBZ      r0,|L5.24|
000014  7808              LDRB     r0,[r1,#0]            ;217
000016  b900              CBNZ     r0,|L5.26|
                  |L5.24|
000018  e003              B        |L5.34|
                  |L5.26|
00001a  7810              LDRB     r0,[r2,#0]            ;212
00001c  780b              LDRB     r3,[r1,#0]            ;212
00001e  4298              CMP      r0,r3                 ;212
000020  d0f4              BEQ      |L5.12|
                  |L5.34|
000022  bf00              NOP                            ;219
000024  7810              LDRB     r0,[r2,#0]            ;223
000026  780b              LDRB     r3,[r1,#0]            ;223
000028  1ac0              SUBS     r0,r0,r3              ;223
00002a  e7ed              B        |L5.8|
;;;225    
                          ENDP


                          AREA ||i.My_Strcpy||, CODE, READONLY, ALIGN=1

                  My_Strcpy PROC
;;;176    //--------------------------------------------------------------------------------------------------------
;;;177    char *My_Strcpy(char *dest, const char *src)
000000  4603              MOV      r3,r0
;;;178    {
;;;179    	char *tmp = (char *)dest;
000002  461a              MOV      r2,r3
;;;180    	
;;;181    	if ((dest == NULL) || (src == NULL))
000004  b103              CBZ      r3,|L6.8|
000006  b909              CBNZ     r1,|L6.12|
                  |L6.8|
;;;182    	{
;;;183    		return 0;
000008  2000              MOVS     r0,#0
                  |L6.10|
;;;184    	}
;;;185    	
;;;186    	while (*src != '\0')
;;;187    	{
;;;188    		*tmp++ = *src++;
;;;189    	}
;;;190    	
;;;191    	*tmp = '\0';	//字符串结束增加'\0'
;;;192    	
;;;193    	return tmp;
;;;194    }
00000a  4770              BX       lr
                  |L6.12|
00000c  e003              B        |L6.22|
                  |L6.14|
00000e  f8110b01          LDRB     r0,[r1],#1            ;188
000012  f8020b01          STRB     r0,[r2],#1            ;188
                  |L6.22|
000016  7808              LDRB     r0,[r1,#0]            ;186
000018  2800              CMP      r0,#0                 ;186
00001a  d1f8              BNE      |L6.14|
00001c  7010              STRB     r0,[r2,#0]            ;191
00001e  4610              MOV      r0,r2                 ;193
000020  e7f3              B        |L6.10|
;;;195    
                          ENDP


                          AREA ||i.My_Strlen||, CODE, READONLY, ALIGN=1

                  My_Strlen PROC
;;;155    //--------------------------------------------------------------------------------------------------------
;;;156    unsigned int My_Strlen(const char *str)
000000  4601              MOV      r1,r0
;;;157    {
;;;158    	int str_len = 0;
000002  2000              MOVS     r0,#0
;;;159    
;;;160    	while (*str++ != '\0')
000004  e000              B        |L7.8|
                  |L7.6|
;;;161    	{
;;;162    		str_len++;
000006  1c40              ADDS     r0,r0,#1
                  |L7.8|
000008  f8113b01          LDRB     r3,[r1],#1            ;160
00000c  2b00              CMP      r3,#0                 ;160
00000e  d1fa              BNE      |L7.6|
;;;163    	}
;;;164    	
;;;165    	return str_len;
;;;166    }
000010  4770              BX       lr
;;;167    
                          ENDP


                          AREA ||i.bubble_sort||, CODE, READONLY, ALIGN=1

                  bubble_sort PROC
;;;334    
;;;335    void bubble_sort(uint32_t *pbdata, uint16_t length)
000000  b5f0              PUSH     {r4-r7,lr}
;;;336    {
000002  4602              MOV      r2,r0
;;;337    	uint16_t i = 0;
000004  2300              MOVS     r3,#0
;;;338    	uint16_t j = 0;
000006  2000              MOVS     r0,#0
;;;339    	uint32_t temp_value = 0;
000008  2400              MOVS     r4,#0
;;;340    	uint8_t sort_flag = 0;
00000a  2500              MOVS     r5,#0
;;;341    	
;;;342    	for (i = 0; i < length-1; i++)
00000c  bf00              NOP      
00000e  e01f              B        |L8.80|
                  |L8.16|
;;;343    	{
;;;344    		sort_flag = 1;
000010  2501              MOVS     r5,#1
;;;345    		
;;;346    		for (j = 0; j < length-1-i; j++)
000012  2000              MOVS     r0,#0
000014  e013              B        |L8.62|
                  |L8.22|
;;;347    		{
;;;348    			if (pbdata[j] > pbdata[j+1])
000016  f8527020          LDR      r7,[r2,r0,LSL #2]
00001a  1c46              ADDS     r6,r0,#1
00001c  f8526026          LDR      r6,[r2,r6,LSL #2]
000020  42b7              CMP      r7,r6
000022  d90a              BLS      |L8.58|
;;;349    			{
;;;350    				temp_value	= pbdata[j];
000024  f8524020          LDR      r4,[r2,r0,LSL #2]
;;;351    				pbdata[j]	= pbdata[j+1];
000028  1c46              ADDS     r6,r0,#1
00002a  f8526026          LDR      r6,[r2,r6,LSL #2]
00002e  f8426020          STR      r6,[r2,r0,LSL #2]
;;;352    				pbdata[j+1]	= temp_value;
000032  1c46              ADDS     r6,r0,#1
000034  f8424026          STR      r4,[r2,r6,LSL #2]
;;;353    				
;;;354    				sort_flag = 0;
000038  2500              MOVS     r5,#0
                  |L8.58|
00003a  1c46              ADDS     r6,r0,#1              ;346
00003c  b2b0              UXTH     r0,r6                 ;346
                  |L8.62|
00003e  1e4e              SUBS     r6,r1,#1              ;346
000040  1af6              SUBS     r6,r6,r3              ;346
000042  4286              CMP      r6,r0                 ;346
000044  dce7              BGT      |L8.22|
;;;355    			}
;;;356    		}
;;;357    		
;;;358    		if (sort_flag == 1)
000046  2d01              CMP      r5,#1
000048  d100              BNE      |L8.76|
;;;359    		{
;;;360    			goto exit;
00004a  e005              B        |L8.88|
                  |L8.76|
00004c  1c5e              ADDS     r6,r3,#1              ;342
00004e  b2b3              UXTH     r3,r6                 ;342
                  |L8.80|
000050  1e4e              SUBS     r6,r1,#1              ;342
000052  429e              CMP      r6,r3                 ;342
000054  dcdc              BGT      |L8.16|
;;;361    		}
;;;362    	}
;;;363    	
;;;364    exit:	
000056  bf00              NOP      
                  |L8.88|
;;;365    	return;
;;;366    }
000058  bdf0              POP      {r4-r7,pc}
;;;367    
                          ENDP


                          AREA ||i.cpu_mem_endian||, CODE, READONLY, ALIGN=2

                  cpu_mem_endian PROC
;;;273    //--------------------------------------------------------------------------------------------------------
;;;274    void cpu_mem_endian(void)
000000  b508              PUSH     {r3,lr}
;;;275    {
;;;276    	union un_test 
;;;277    	{
;;;278    		uint8_t x;
;;;279    		uint16_t y;
;;;280    	}un_endian_test;
;;;281    	
;;;282    	un_endian_test.y = 0x1234;
000002  f2412034          MOV      r0,#0x1234
000006  9000              STR      r0,[sp,#0]
;;;283    	
;;;284    	if (un_endian_test.x == 0x34)
000008  f89d0000          LDRB     r0,[sp,#0]
00000c  2834              CMP      r0,#0x34
00000e  d102              BNE      |L9.22|
;;;285    	{
;;;286    		printf("cpu is little endian \r\n");
000010  a005              ADR      r0,|L9.40|
000012  f7fffffe          BL       __2printf
                  |L9.22|
;;;287    	}
;;;288    	if (un_endian_test.x == 0x12)
000016  f89d0000          LDRB     r0,[sp,#0]
00001a  2812              CMP      r0,#0x12
00001c  d102              BNE      |L9.36|
;;;289    	{
;;;290    		printf("cpu is big endian \r\n");
00001e  a008              ADR      r0,|L9.64|
000020  f7fffffe          BL       __2printf
                  |L9.36|
;;;291    	}
;;;292    }
000024  bd08              POP      {r3,pc}
;;;293    
                          ENDP

000026  0000              DCW      0x0000
                  |L9.40|
000028  63707520          DCB      "cpu is little endian \r\n",0
00002c  6973206c
000030  6974746c
000034  6520656e
000038  6469616e
00003c  200d0a00
                  |L9.64|
000040  63707520          DCB      "cpu is big endian \r\n",0
000044  69732062
000048  69672065
00004c  6e646961
000050  6e200d0a
000054  00      
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0

                          AREA ||i.memcmp_test||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  memcmp_test PROC
;;;246    
;;;247    void memcmp_test(void)
000000  b51f              PUSH     {r0-r4,lr}
;;;248    {
;;;249    	char str1[] = "abcd";
000002  a017              ADR      r0,|L10.96|
000004  c803              LDM      r0,{r0,r1}
000006  e9cd0102          STRD     r0,r1,[sp,#8]
;;;250    	char str2[] = "abcd";
00000a  a115              ADR      r1,|L10.96|
00000c  c903              LDM      r1,{r0,r1}
00000e  e9cd0100          STRD     r0,r1,[sp,#0]
;;;251    	int ret = 0;
000012  2400              MOVS     r4,#0
;;;252    
;;;253    	ret = My_Memcmp(str1, str2, 4);
000014  2204              MOVS     r2,#4
000016  4669              MOV      r1,sp
000018  a802              ADD      r0,sp,#8
00001a  f7fffffe          BL       My_Memcmp
00001e  4604              MOV      r4,r0
;;;254    	printf("ret val is %d \r\n", ret);
000020  4621              MOV      r1,r4
000022  a011              ADR      r0,|L10.104|
000024  f7fffffe          BL       __2printf
;;;255    
;;;256    	memcpy(str1, "abce", 4);
000028  a014              ADR      r0,|L10.124|
00002a  6800              LDR      r0,[r0,#0]
00002c  9002              STR      r0,[sp,#8]
;;;257    	ret = My_Memcmp(str1, str2, 4);
00002e  2204              MOVS     r2,#4
000030  4669              MOV      r1,sp
000032  a802              ADD      r0,sp,#8
000034  f7fffffe          BL       My_Memcmp
000038  4604              MOV      r4,r0
;;;258    	printf("ret val is %d \r\n", ret);
00003a  4621              MOV      r1,r4
00003c  a00a              ADR      r0,|L10.104|
00003e  f7fffffe          BL       __2printf
;;;259    
;;;260    	memcpy(str1, "abcc", 4);
000042  a010              ADR      r0,|L10.132|
000044  6800              LDR      r0,[r0,#0]
000046  9002              STR      r0,[sp,#8]
;;;261    	ret = My_Memcmp(str1, str2, 4);
000048  2204              MOVS     r2,#4
00004a  4669              MOV      r1,sp
00004c  a802              ADD      r0,sp,#8
00004e  f7fffffe          BL       My_Memcmp
000052  4604              MOV      r4,r0
;;;262    	printf("ret val is %d \r\n", ret);
000054  4621              MOV      r1,r4
000056  a004              ADR      r0,|L10.104|
000058  f7fffffe          BL       __2printf
;;;263    }
00005c  bd1f              POP      {r0-r4,pc}
;;;264    
                          ENDP

00005e  0000              DCW      0x0000
                  |L10.96|
000060  61626364          DCB      "abcd",0
000064  00      
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0
                  |L10.104|
000068  72657420          DCB      "ret val is %d \r\n",0
00006c  76616c20
000070  69732025
000074  64200d0a
000078  00      
000079  00                DCB      0
00007a  00                DCB      0
00007b  00                DCB      0
                  |L10.124|
00007c  61626365          DCB      "abce",0
000080  00      
000081  00                DCB      0
000082  00                DCB      0
000083  00                DCB      0
                  |L10.132|
000084  61626363          DCB      "abcc",0
000088  00      
000089  00                DCB      0
00008a  00                DCB      0
00008b  00                DCB      0

                          AREA ||i.sprintf_test||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_return_value
                          REQUIRE _printf_f
                          REQUIRE _printf_fp_dec
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  sprintf_test PROC
;;;20     //--------------------------------------------------------------------------------------------------------
;;;21     void sprintf_test(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;22     {
000002  b09b              SUB      sp,sp,#0x6c
;;;23     	char buf[100] = {0};
000004  2164              MOVS     r1,#0x64
000006  a802              ADD      r0,sp,#8
000008  f7fffffe          BL       __aeabi_memclr4
;;;24     	double data = 3.141593;
00000c  4e1b              LDR      r6,|L11.124|
00000e  4f1c              LDR      r7,|L11.128|
;;;25     	uint16_t len = 0;
000010  2500              MOVS     r5,#0
;;;26     	uint8_t test_buff[5] = {55, 22, 66, 77, 99};
000012  a11c              ADR      r1,|L11.132|
000014  c903              LDM      r1,{r0,r1}
000016  e9cd0100          STRD     r0,r1,[sp,#0]
;;;27     	
;;;28     	len = sprintf((char *)buf, "%f", data);
00001a  4632              MOV      r2,r6
00001c  463b              MOV      r3,r7
00001e  a11b              ADR      r1,|L11.140|
000020  a802              ADD      r0,sp,#8
000022  f7fffffe          BL       __2sprintf
000026  b285              UXTH     r5,r0
;;;29     	printf("----------------------------------------------------------------- \r\n");
000028  4819              LDR      r0,|L11.144|
00002a  f7fffffe          BL       __2printf
;;;30     	printf("buf is %s \r\n", buf);
00002e  a902              ADD      r1,sp,#8
000030  a018              ADR      r0,|L11.148|
000032  f7fffffe          BL       __2printf
;;;31     	printf("sprintf return len is %d \r\n", len);
000036  4629              MOV      r1,r5
000038  a01a              ADR      r0,|L11.164|
00003a  f7fffffe          BL       __2printf
;;;32     	
;;;33     	len = 0;
00003e  2500              MOVS     r5,#0
;;;34     	
;;;35     	for (uint16_t i = 0; i < sizeof(test_buff); i++)
000040  2400              MOVS     r4,#0
000042  e00b              B        |L11.92|
                  |L11.68|
;;;36     	{
;;;37     		len += sprintf((char *)buf + i * 2, "%d", test_buff[i]);	//数组数据转换为字符串
000044  f81d2004          LDRB     r2,[sp,r4]
000048  a902              ADD      r1,sp,#8
00004a  eb010044          ADD      r0,r1,r4,LSL #1
00004e  a11c              ADR      r1,|L11.192|
000050  f7fffffe          BL       __2sprintf
000054  4428              ADD      r0,r0,r5
000056  b285              UXTH     r5,r0
000058  1c60              ADDS     r0,r4,#1              ;35
00005a  b284              UXTH     r4,r0                 ;35
                  |L11.92|
00005c  2c05              CMP      r4,#5                 ;35
00005e  d3f1              BCC      |L11.68|
;;;38     	}
;;;39     	printf("test_buff val is %s \r\n", buf);
000060  a902              ADD      r1,sp,#8
000062  a018              ADR      r0,|L11.196|
000064  f7fffffe          BL       __2printf
;;;40     	printf("sprintf return len is %d \r\n", len);
000068  4629              MOV      r1,r5
00006a  a00e              ADR      r0,|L11.164|
00006c  f7fffffe          BL       __2printf
;;;41     	printf("----------------------------------------------------------------- \r\n");
000070  4807              LDR      r0,|L11.144|
000072  f7fffffe          BL       __2printf
;;;42     }
000076  b01b              ADD      sp,sp,#0x6c
000078  bdf0              POP      {r4-r7,pc}
;;;43     
                          ENDP

00007a  0000              DCW      0x0000
                  |L11.124|
                          DCD      0x82c2bd7f
                  |L11.128|
                          DCD      0x400921fb
                  |L11.132|
000084  3716424d          DCB      "7",22,"BMc",0
000088  6300    
00008a  00                DCB      0
00008b  00                DCB      0
                  |L11.140|
00008c  256600            DCB      "%f",0
00008f  00                DCB      0
                  |L11.144|
                          DCD      ||.conststring||
                  |L11.148|
000094  62756620          DCB      "buf is %s \r\n",0
000098  69732025
00009c  73200d0a
0000a0  00      
0000a1  00                DCB      0
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L11.164|
0000a4  73707269          DCB      "sprintf return len is %d \r\n",0
0000a8  6e746620
0000ac  72657475
0000b0  726e206c
0000b4  656e2069
0000b8  73202564
0000bc  200d0a00
                  |L11.192|
0000c0  256400            DCB      "%d",0
0000c3  00                DCB      0
                  |L11.196|
0000c4  74657374          DCB      "test_buff val is %s \r\n",0
0000c8  5f627566
0000cc  66207661
0000d0  6c206973
0000d4  20257320
0000d8  0d0a00  
0000db  00                DCB      0

                          AREA ||i.strcmp_test||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  strcmp_test PROC
;;;225    
;;;226    void strcmp_test(void)
000000  b51f              PUSH     {r0-r4,lr}
;;;227    {
;;;228    	int ret = 0;
000002  2400              MOVS     r4,#0
;;;229    //	char test_buf1[6] = "ABCBE";
;;;230    //	char test_buf2[3] = "AB";
;;;231    	char test_buf1[6] = {1, 2, 3, 4, 5, 6};
000004  a108              ADR      r1,|L12.40|
000006  c903              LDM      r1,{r0,r1}
000008  e9cd0102          STRD     r0,r1,[sp,#8]
;;;232    	char test_buf2[6] = {1, 2, 3, 7, 5, 6};
00000c  a108              ADR      r1,|L12.48|
00000e  c903              LDM      r1,{r0,r1}
000010  e9cd0100          STRD     r0,r1,[sp,#0]
;;;233    	
;;;234    	ret = My_Strcmp(test_buf1, test_buf2);
000014  4669              MOV      r1,sp
000016  a802              ADD      r0,sp,#8
000018  f7fffffe          BL       My_Strcmp
00001c  4604              MOV      r4,r0
;;;235    	printf("ret val is %d \r\n", ret);
00001e  4621              MOV      r1,r4
000020  a005              ADR      r0,|L12.56|
000022  f7fffffe          BL       __2printf
;;;236    }
000026  bd1f              POP      {r0-r4,pc}
;;;237    	
                          ENDP

                  |L12.40|
000028  01020304          DCB      1,2,3,4,5,6,0
00002c  050600  
00002f  00                DCB      0
                  |L12.48|
000030  01020307          DCB      1,2,3,"\a",5,6,0
000034  050600  
000037  00                DCB      0
                  |L12.56|
000038  72657420          DCB      "ret val is %d \r\n",0
00003c  76616c20
000040  69732025
000044  64200d0a
000048  00      
000049  00                DCB      0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||i.strcpy_test||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  strcpy_test PROC
;;;237    	
;;;238    void strcpy_test(void)
000000  b500              PUSH     {lr}
;;;239    {
000002  b09b              SUB      sp,sp,#0x6c
;;;240    	char test_buf1[6] = "ABCDE";
000004  a108              ADR      r1,|L13.40|
000006  c903              LDM      r1,{r0,r1}
000008  e9cd0119          STRD     r0,r1,[sp,#0x64]
;;;241    	char test_buf2[100] = {0};
00000c  2164              MOVS     r1,#0x64
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       __aeabi_memclr4
;;;242    	
;;;243    	My_Strcpy(test_buf2, test_buf1);
000014  a919              ADD      r1,sp,#0x64
000016  4668              MOV      r0,sp
000018  f7fffffe          BL       My_Strcpy
;;;244    	printf("strcpy test %s \r\n", test_buf2);
00001c  4669              MOV      r1,sp
00001e  a004              ADR      r0,|L13.48|
000020  f7fffffe          BL       __2printf
;;;245    }
000024  b01b              ADD      sp,sp,#0x6c
000026  bd00              POP      {pc}
;;;246    
                          ENDP

                  |L13.40|
000028  41424344          DCB      "ABCDE",0
00002c  4500    
00002e  00                DCB      0
00002f  00                DCB      0
                  |L13.48|
000030  73747263          DCB      "strcpy test %s \r\n",0
000034  70792074
000038  65737420
00003c  2573200d
000040  0a00    
000042  00                DCB      0
000043  00                DCB      0

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  2d2d2d2d          DCB      "-------------------------------------------------------"
000004  2d2d2d2d
000008  2d2d2d2d
00000c  2d2d2d2d
000010  2d2d2d2d
000014  2d2d2d2d
000018  2d2d2d2d
00001c  2d2d2d2d
000020  2d2d2d2d
000024  2d2d2d2d
000028  2d2d2d2d
00002c  2d2d2d2d
000030  2d2d2d2d
000034  2d2d2d  
000037  2d2d2d2d          DCB      "---------- \r\n",0
00003b  2d2d2d2d
00003f  2d2d200d
000043  0a00    
