; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\drvuart.o --asm_dir=.\ --list_dir=.\ --depend=.\drvuart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\App\inc -I..\Driver\inc -I..\Libraries\CMSIS\Core\inc -I..\Libraries\CMSIS\Device\inc -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\HalIterface\inc -I..\User\inc -I..\Driver\src -ID:\KEIL_ARM_PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\keil_arm\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=533 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\drvuart.crf ..\Driver\src\drvuart.c]
                          THUMB

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;503    //-------------------------------------------------------------------------------------------------------------------------
;;;504    void USART1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;505    {
;;;506    	if (USART_GetITStatus(USART1, USART_IT_RXNE) == SET)	//检查接收中断标志位
000002  f2405125          MOV      r1,#0x525
000006  4806              LDR      r0,|L1.32|
000008  f7fffffe          BL       USART_GetITStatus
00000c  2801              CMP      r0,#1
00000e  d106              BNE      |L1.30|
;;;507    	{	
;;;508    //		USART_ClearITPendingBit(USART1, USART_IT_RXNE);
;;;509    		
;;;510    		uart_test();	//接收的数据处理
000010  f7fffffe          BL       uart_test
;;;511    
;;;512    		USART_ClearITPendingBit(USART1, USART_IT_RXNE);	//清除串口接收中断标志
000014  f2405125          MOV      r1,#0x525
000018  4801              LDR      r0,|L1.32|
00001a  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.30|
;;;513    	}
;;;514    }
00001e  bd10              POP      {r4,pc}
;;;515    
                          ENDP

                  |L1.32|
                          DCD      0x40013800

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;31     
;;;32     int fputc(int ch, FILE *f)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;33     {      
000002  460c              MOV      r4,r1
;;;34     //	while((USART1->SR & 0X40) == 0);//循环发送,直到发送完毕   
;;;35     //    USART1->DR = (uint8_t)ch;      
;;;36     	
;;;37     //	 uart_send_byte(1, (uint8_t)ch);
;;;38     
;;;39     	uart_send_serial_bytes(1, (uint8_t *)&ch, 1);
000004  2201              MOVS     r2,#1
000006  4669              MOV      r1,sp
000008  4610              MOV      r0,r2
00000a  f7fffffe          BL       uart_send_serial_bytes
;;;40     	
;;;41     	return ch;
00000e  9800              LDR      r0,[sp,#0]
;;;42     }
000010  bd1c              POP      {r2-r4,pc}
;;;43     
                          ENDP


                          AREA ||i.uart_config||, CODE, READONLY, ALIGN=2

                  uart_config PROC
;;;137    //-------------------------------------------------------------------------------------------------------------------------
;;;138    static void uart_config(uint8_t uart_chl, uint32_t uart_bound)
000000  b57f              PUSH     {r0-r6,lr}
;;;139    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;140        USART_InitTypeDef uart_config_init;
;;;141    
;;;142        if (uart_chl == 1)
000006  2d01              CMP      r5,#1
000008  d119              BNE      |L3.62|
;;;143        {
;;;144    		RCC_APB2PeriphClockCmd(RCC_PCLK_USART1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  0380              LSLS     r0,r0,#14
00000e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;145    		
;;;146    		uart_config_init.USART_BaudRate              = uart_bound;	//串口波特率
000012  9400              STR      r4,[sp,#0]
;;;147    		uart_config_init.USART_WordLength            = USART_WordLength_8b;	//字长为8位数据格式
000014  2000              MOVS     r0,#0
000016  f8ad0004          STRH     r0,[sp,#4]
;;;148    		uart_config_init.USART_StopBits              = USART_StopBits_1;	//一个停止位
00001a  f8ad0006          STRH     r0,[sp,#6]
;;;149    		uart_config_init.USART_Parity                = USART_Parity_No;	//无奇偶校验位
00001e  f8ad0008          STRH     r0,[sp,#8]
;;;150    		uart_config_init.USART_HardwareFlowControl   = USART_HardwareFlowControl_None;	//无硬件数据流控制
000022  f8ad000c          STRH     r0,[sp,#0xc]
;;;151    		uart_config_init.USART_Mode                  = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
000026  200c              MOVS     r0,#0xc
000028  f8ad000a          STRH     r0,[sp,#0xa]
;;;152    
;;;153    		USART_Init(USART1, &uart_config_init); //初始化串口1
00002c  4669              MOV      r1,sp
00002e  483c              LDR      r0,|L3.288|
000030  f7fffffe          BL       USART_Init
;;;154    		// USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启串口接受中断(串口参数初始化之后才能开启中断)
;;;155    		USART_Cmd(USART1, ENABLE); 		//使能串口1 
000034  2101              MOVS     r1,#1
000036  483a              LDR      r0,|L3.288|
000038  f7fffffe          BL       USART_Cmd
00003c  e06e              B        |L3.284|
                  |L3.62|
;;;156        }
;;;157        else if (uart_chl == 2)
00003e  2d02              CMP      r5,#2
000040  d119              BNE      |L3.118|
;;;158        {
;;;159    		RCC_APB2PeriphClockCmd(RCC_PCLK_USART2, ENABLE);
000042  2101              MOVS     r1,#1
000044  0448              LSLS     r0,r1,#17
000046  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;160    		
;;;161    		uart_config_init.USART_BaudRate             = uart_bound;//串口波特率
00004a  9400              STR      r4,[sp,#0]
;;;162    		uart_config_init.USART_WordLength           = USART_WordLength_8b;//字长为8位数据格式
00004c  2000              MOVS     r0,#0
00004e  f8ad0004          STRH     r0,[sp,#4]
;;;163    		uart_config_init.USART_StopBits             = USART_StopBits_1;//一个停止位
000052  f8ad0006          STRH     r0,[sp,#6]
;;;164    		uart_config_init.USART_Parity               = USART_Parity_No;//无奇偶校验位
000056  f8ad0008          STRH     r0,[sp,#8]
;;;165    		uart_config_init.USART_HardwareFlowControl  = USART_HardwareFlowControl_None;//无硬件数据流控制
00005a  f8ad000c          STRH     r0,[sp,#0xc]
;;;166    		uart_config_init.USART_Mode                 = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
00005e  200c              MOVS     r0,#0xc
000060  f8ad000a          STRH     r0,[sp,#0xa]
;;;167    
;;;168    		USART_Init(USART2, &uart_config_init); //初始化串口1
000064  4669              MOV      r1,sp
000066  482f              LDR      r0,|L3.292|
000068  f7fffffe          BL       USART_Init
;;;169    		// USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);//开启串口接受中断
;;;170    		USART_Cmd(USART2, ENABLE); 		//使能串口1 
00006c  2101              MOVS     r1,#1
00006e  482d              LDR      r0,|L3.292|
000070  f7fffffe          BL       USART_Cmd
000074  e052              B        |L3.284|
                  |L3.118|
;;;171        }
;;;172        else if (uart_chl == 3)
000076  2d03              CMP      r5,#3
000078  d119              BNE      |L3.174|
;;;173        {
;;;174    		RCC_APB2PeriphClockCmd(RCC_PCLK_USART3, ENABLE);
00007a  2101              MOVS     r1,#1
00007c  0488              LSLS     r0,r1,#18
00007e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;175    		
;;;176    		uart_config_init.USART_BaudRate             = uart_bound;//串口波特率
000082  9400              STR      r4,[sp,#0]
;;;177    		uart_config_init.USART_WordLength           = USART_WordLength_8b;//字长为8位数据格式
000084  2000              MOVS     r0,#0
000086  f8ad0004          STRH     r0,[sp,#4]
;;;178    		uart_config_init.USART_StopBits             = USART_StopBits_1;//一个停止位
00008a  f8ad0006          STRH     r0,[sp,#6]
;;;179    		uart_config_init.USART_Parity               = USART_Parity_No;//无奇偶校验位
00008e  f8ad0008          STRH     r0,[sp,#8]
;;;180    		uart_config_init.USART_HardwareFlowControl  = USART_HardwareFlowControl_None;//无硬件数据流控制
000092  f8ad000c          STRH     r0,[sp,#0xc]
;;;181    		uart_config_init.USART_Mode                 = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
000096  200c              MOVS     r0,#0xc
000098  f8ad000a          STRH     r0,[sp,#0xa]
;;;182    
;;;183    		USART_Init(USART3, &uart_config_init); //初始化串口1
00009c  4669              MOV      r1,sp
00009e  4822              LDR      r0,|L3.296|
0000a0  f7fffffe          BL       USART_Init
;;;184    		// USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);//开启串口接受中断
;;;185    		USART_Cmd(USART3, ENABLE); 		//使能串口1 
0000a4  2101              MOVS     r1,#1
0000a6  4820              LDR      r0,|L3.296|
0000a8  f7fffffe          BL       USART_Cmd
0000ac  e036              B        |L3.284|
                  |L3.174|
;;;186        }
;;;187        else if (uart_chl == 4)
0000ae  2d04              CMP      r5,#4
0000b0  d119              BNE      |L3.230|
;;;188        {
;;;189    		RCC_APB2PeriphClockCmd(RCC_PCLK_USART4, ENABLE);
0000b2  2101              MOVS     r1,#1
0000b4  04c8              LSLS     r0,r1,#19
0000b6  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;190    		
;;;191    		uart_config_init.USART_BaudRate             = uart_bound;//串口波特率
0000ba  9400              STR      r4,[sp,#0]
;;;192    		uart_config_init.USART_WordLength           = USART_WordLength_8b;//字长为8位数据格式
0000bc  2000              MOVS     r0,#0
0000be  f8ad0004          STRH     r0,[sp,#4]
;;;193    		uart_config_init.USART_StopBits             = USART_StopBits_1;//一个停止位
0000c2  f8ad0006          STRH     r0,[sp,#6]
;;;194    		uart_config_init.USART_Parity               = USART_Parity_No;//无奇偶校验位
0000c6  f8ad0008          STRH     r0,[sp,#8]
;;;195    		uart_config_init.USART_HardwareFlowControl  = USART_HardwareFlowControl_None;//无硬件数据流控制
0000ca  f8ad000c          STRH     r0,[sp,#0xc]
;;;196    		uart_config_init.USART_Mode                 = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
0000ce  200c              MOVS     r0,#0xc
0000d0  f8ad000a          STRH     r0,[sp,#0xa]
;;;197    
;;;198    		USART_Init(UART4, &uart_config_init); //初始化串口1
0000d4  4669              MOV      r1,sp
0000d6  4815              LDR      r0,|L3.300|
0000d8  f7fffffe          BL       USART_Init
;;;199    //		USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);//开启串口接受中断
;;;200    		USART_Cmd(UART4, ENABLE); 		//使能串口1 
0000dc  2101              MOVS     r1,#1
0000de  4813              LDR      r0,|L3.300|
0000e0  f7fffffe          BL       USART_Cmd
0000e4  e01a              B        |L3.284|
                  |L3.230|
;;;201        }
;;;202        else if (uart_chl == 5)
0000e6  2d05              CMP      r5,#5
0000e8  d118              BNE      |L3.284|
;;;203        {
;;;204    		RCC_APB2PeriphClockCmd(RCC_PCLK_USART5, ENABLE);
0000ea  2101              MOVS     r1,#1
0000ec  0508              LSLS     r0,r1,#20
0000ee  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;205    		
;;;206    		uart_config_init.USART_BaudRate             = uart_bound;//串口波特率
0000f2  9400              STR      r4,[sp,#0]
;;;207    		uart_config_init.USART_WordLength           = USART_WordLength_8b;//字长为8位数据格式
0000f4  2000              MOVS     r0,#0
0000f6  f8ad0004          STRH     r0,[sp,#4]
;;;208    		uart_config_init.USART_StopBits             = USART_StopBits_1;//一个停止位
0000fa  f8ad0006          STRH     r0,[sp,#6]
;;;209    		uart_config_init.USART_Parity               = USART_Parity_No;//无奇偶校验位
0000fe  f8ad0008          STRH     r0,[sp,#8]
;;;210    		uart_config_init.USART_HardwareFlowControl  = USART_HardwareFlowControl_None;//无硬件数据流控制
000102  f8ad000c          STRH     r0,[sp,#0xc]
;;;211    		uart_config_init.USART_Mode                 = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
000106  200c              MOVS     r0,#0xc
000108  f8ad000a          STRH     r0,[sp,#0xa]
;;;212    
;;;213    		USART_Init(UART5, &uart_config_init); //初始化串口1
00010c  4669              MOV      r1,sp
00010e  4808              LDR      r0,|L3.304|
000110  f7fffffe          BL       USART_Init
;;;214    //		USART_ITConfig(UART5, USART_IT_RXNE, ENABLE);//开启串口接受中断
;;;215    		USART_Cmd(UART5, ENABLE); 		//使能串口1 
000114  2101              MOVS     r1,#1
000116  4806              LDR      r0,|L3.304|
000118  f7fffffe          BL       USART_Cmd
                  |L3.284|
;;;216        }
;;;217        else 
;;;218        {
;;;219    //        printf("error! \r\n");
;;;220        }
;;;221    }
00011c  bd7f              POP      {r0-r6,pc}
;;;222    
                          ENDP

00011e  0000              DCW      0x0000
                  |L3.288|
                          DCD      0x40013800
                  |L3.292|
                          DCD      0x40004400
                  |L3.296|
                          DCD      0x40004800
                  |L3.300|
                          DCD      0x40004c00
                  |L3.304|
                          DCD      0x40005000

                          AREA ||i.uart_gpio_init||, CODE, READONLY, ALIGN=2

                  uart_gpio_init PROC
;;;52     //-------------------------------------------------------------------------------------------------------------------------
;;;53     static void uart_gpio_init(uint8_t uart_chl)
000000  b538              PUSH     {r3-r5,lr}
;;;54     {
000002  4604              MOV      r4,r0
;;;55         GPIO_InitTypeDef gpio_config_init;
;;;56     
;;;57         if (uart_chl == 1)
000004  2c01              CMP      r4,#1
000006  d11b              BNE      |L4.64|
;;;58         {
;;;59             RCC_APB2PeriphClockCmd(RCC_PCLK_USART1_GPIO, ENABLE);	//使能UART1 GPIO时钟,APB2总线
000008  2101              MOVS     r1,#1
00000a  2004              MOVS     r0,#4
00000c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;60     
;;;61     		gpio_config_init.GPIO_Pin 	= USART1_TXD_IO; //PA9
000010  0260              LSLS     r0,r4,#9
000012  f8ad0000          STRH     r0,[sp,#0]
;;;62     		gpio_config_init.GPIO_Speed = GPIO_Speed_50MHz;
000016  2003              MOVS     r0,#3
000018  f88d0002          STRB     r0,[sp,#2]
;;;63     		gpio_config_init.GPIO_Mode 	= GPIO_Mode_AF_PP;	//复用推挽输出
00001c  2018              MOVS     r0,#0x18
00001e  f88d0003          STRB     r0,[sp,#3]
;;;64     		GPIO_Init(USART1_TXD_PORT, &gpio_config_init);//初始化GPIOA9
000022  4669              MOV      r1,sp
000024  4843              LDR      r0,|L4.308|
000026  f7fffffe          BL       GPIO_Init
;;;65     
;;;66     		gpio_config_init.GPIO_Pin 	= USART1_RXD_IO;//PA10
00002a  02a0              LSLS     r0,r4,#10
00002c  f8ad0000          STRH     r0,[sp,#0]
;;;67     		gpio_config_init.GPIO_Mode 	= GPIO_Mode_IN_FLOATING;//浮空输入
000030  2004              MOVS     r0,#4
000032  f88d0003          STRB     r0,[sp,#3]
;;;68     		GPIO_Init(USART1_RXD_PORT, &gpio_config_init);//初始化GPIOA10
000036  4669              MOV      r1,sp
000038  483e              LDR      r0,|L4.308|
00003a  f7fffffe          BL       GPIO_Init
00003e  e078              B        |L4.306|
                  |L4.64|
;;;69         }
;;;70         else if (uart_chl == 2)
000040  2c02              CMP      r4,#2
000042  d11b              BNE      |L4.124|
;;;71         {
;;;72             RCC_APB2PeriphClockCmd(RCC_PCLK_USART2_GPIO, ENABLE);	//使能UART2 GPIO时钟,ABP2总线
000044  2101              MOVS     r1,#1
000046  2004              MOVS     r0,#4
000048  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;73     
;;;74     		gpio_config_init.GPIO_Pin = USART2_TXD_IO; //PA2
00004c  2004              MOVS     r0,#4
00004e  f8ad0000          STRH     r0,[sp,#0]
;;;75     		gpio_config_init.GPIO_Speed = GPIO_Speed_50MHz;
000052  2003              MOVS     r0,#3
000054  f88d0002          STRB     r0,[sp,#2]
;;;76     		gpio_config_init.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽输出
000058  2018              MOVS     r0,#0x18
00005a  f88d0003          STRB     r0,[sp,#3]
;;;77     		GPIO_Init(USART2_TXD_PORT, &gpio_config_init);//初始化GPIOA2
00005e  4669              MOV      r1,sp
000060  4834              LDR      r0,|L4.308|
000062  f7fffffe          BL       GPIO_Init
;;;78     
;;;79     		gpio_config_init.GPIO_Pin = USART2_RXD_IO;//PA3
000066  2008              MOVS     r0,#8
000068  f8ad0000          STRH     r0,[sp,#0]
;;;80     		gpio_config_init.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
00006c  2004              MOVS     r0,#4
00006e  f88d0003          STRB     r0,[sp,#3]
;;;81     		GPIO_Init(USART2_RXD_PORT, &gpio_config_init);//初始化GPIOA3  
000072  4669              MOV      r1,sp
000074  482f              LDR      r0,|L4.308|
000076  f7fffffe          BL       GPIO_Init
00007a  e05a              B        |L4.306|
                  |L4.124|
;;;82         }
;;;83         else if (uart_chl == 3)
00007c  2c03              CMP      r4,#3
00007e  d11d              BNE      |L4.188|
;;;84         {
;;;85             RCC_APB2PeriphClockCmd(RCC_PCLK_USART3_GPIO, ENABLE);	//使能UART3 GPIO时钟,ABP2总线
000080  2101              MOVS     r1,#1
000082  2008              MOVS     r0,#8
000084  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;86     
;;;87     		gpio_config_init.GPIO_Pin = USART3_TXD_IO; //PB10
000088  f44f6080          MOV      r0,#0x400
00008c  f8ad0000          STRH     r0,[sp,#0]
;;;88     		gpio_config_init.GPIO_Speed = GPIO_Speed_50MHz;
000090  2003              MOVS     r0,#3
000092  f88d0002          STRB     r0,[sp,#2]
;;;89     		gpio_config_init.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽输出
000096  2018              MOVS     r0,#0x18
000098  f88d0003          STRB     r0,[sp,#3]
;;;90     		GPIO_Init(USART3_TXD_PORT, &gpio_config_init);//初始化GPIOB10
00009c  4669              MOV      r1,sp
00009e  4826              LDR      r0,|L4.312|
0000a0  f7fffffe          BL       GPIO_Init
;;;91     
;;;92     		gpio_config_init.GPIO_Pin = USART3_RXD_IO;//PB11
0000a4  f44f6000          MOV      r0,#0x800
0000a8  f8ad0000          STRH     r0,[sp,#0]
;;;93     		gpio_config_init.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
0000ac  2004              MOVS     r0,#4
0000ae  f88d0003          STRB     r0,[sp,#3]
;;;94     		GPIO_Init(USART3_RXD_PORT, &gpio_config_init);//初始化GPIOB11 
0000b2  4669              MOV      r1,sp
0000b4  4820              LDR      r0,|L4.312|
0000b6  f7fffffe          BL       GPIO_Init
0000ba  e03a              B        |L4.306|
                  |L4.188|
;;;95         }
;;;96         else if (uart_chl == 4)
0000bc  2c04              CMP      r4,#4
0000be  d11b              BNE      |L4.248|
;;;97         {
;;;98             RCC_APB2PeriphClockCmd(RCC_PCLK_USART4_GPIO, ENABLE);	//使能UART4 GPIO时钟,ABP2总线
0000c0  2101              MOVS     r1,#1
0000c2  2010              MOVS     r0,#0x10
0000c4  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;99     
;;;100    		gpio_config_init.GPIO_Pin = USART4_TXD_IO; //PC10
0000c8  0220              LSLS     r0,r4,#8
0000ca  f8ad0000          STRH     r0,[sp,#0]
;;;101    		gpio_config_init.GPIO_Speed = GPIO_Speed_50MHz;
0000ce  2003              MOVS     r0,#3
0000d0  f88d0002          STRB     r0,[sp,#2]
;;;102    		gpio_config_init.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽输出
0000d4  2018              MOVS     r0,#0x18
0000d6  f88d0003          STRB     r0,[sp,#3]
;;;103    		GPIO_Init(USART4_TXD_PORT, &gpio_config_init);//初始化GPIOC10
0000da  4669              MOV      r1,sp
0000dc  4817              LDR      r0,|L4.316|
0000de  f7fffffe          BL       GPIO_Init
;;;104    
;;;105    		gpio_config_init.GPIO_Pin = USART4_RXD_IO;//PC11
0000e2  0260              LSLS     r0,r4,#9
0000e4  f8ad0000          STRH     r0,[sp,#0]
;;;106    		gpio_config_init.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
0000e8  2004              MOVS     r0,#4
0000ea  f88d0003          STRB     r0,[sp,#3]
;;;107    		GPIO_Init(USART4_RXD_PORT, &gpio_config_init);//初始化GPIOC11 
0000ee  4669              MOV      r1,sp
0000f0  4812              LDR      r0,|L4.316|
0000f2  f7fffffe          BL       GPIO_Init
0000f6  e01c              B        |L4.306|
                  |L4.248|
;;;108        }
;;;109         else if (uart_chl == 5)
0000f8  2c05              CMP      r4,#5
0000fa  d11a              BNE      |L4.306|
;;;110        {
;;;111            RCC_APB2PeriphClockCmd(RCC_PCLK_USART5_GPIO, ENABLE);	//使能UART4 GPIO时钟,ABP2总线
0000fc  2101              MOVS     r1,#1
0000fe  2030              MOVS     r0,#0x30
000100  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;112    
;;;113    		gpio_config_init.GPIO_Pin = USART5_TXD_IO; //PC12
000104  f44f5080          MOV      r0,#0x1000
000108  f8ad0000          STRH     r0,[sp,#0]
;;;114    		gpio_config_init.GPIO_Speed = GPIO_Speed_50MHz;
00010c  2003              MOVS     r0,#3
00010e  f88d0002          STRB     r0,[sp,#2]
;;;115    		gpio_config_init.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽输出
000112  2018              MOVS     r0,#0x18
000114  f88d0003          STRB     r0,[sp,#3]
;;;116    		GPIO_Init(USART5_TXD_PORT, &gpio_config_init);	//初始化GPIOC12
000118  4669              MOV      r1,sp
00011a  4808              LDR      r0,|L4.316|
00011c  f7fffffe          BL       GPIO_Init
;;;117    
;;;118    		gpio_config_init.GPIO_Pin = USART5_RXD_IO;	//PC11
000120  2004              MOVS     r0,#4
000122  f8ad0000          STRH     r0,[sp,#0]
;;;119    		gpio_config_init.GPIO_Mode = GPIO_Mode_IN_FLOATING;	//浮空输入
000126  f88d0003          STRB     r0,[sp,#3]
;;;120    		GPIO_Init(USART5_RXD_PORT, &gpio_config_init);	//初始化GPIOD2
00012a  4669              MOV      r1,sp
00012c  4804              LDR      r0,|L4.320|
00012e  f7fffffe          BL       GPIO_Init
                  |L4.306|
;;;121        }
;;;122        else 
;;;123        {
;;;124    //        printf("error! \r\n");
;;;125        }
;;;126    }
000132  bd38              POP      {r3-r5,pc}
;;;127    
                          ENDP

                  |L4.308|
                          DCD      0x40010800
                  |L4.312|
                          DCD      0x40010c00
                  |L4.316|
                          DCD      0x40011000
                  |L4.320|
                          DCD      0x40011400

                          AREA ||i.uart_init||, CODE, READONLY, ALIGN=2

                  uart_init PROC
;;;301    //-------------------------------------------------------------------------------------------------------------------------
;;;302    void uart_init(uint8_t uart_chl, uint32_t uart_bound)
000000  b570              PUSH     {r4-r6,lr}
;;;303    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;304        if (uart_chl == 1)
000006  2c01              CMP      r4,#1
000008  d10a              BNE      |L5.32|
;;;305        {
;;;306            uart_gpio_init(uart_chl);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       uart_gpio_init
;;;307            uart_config(uart_chl, uart_bound);
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       uart_config
;;;308    		uart_irq_set(uart_chl);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       uart_irq_set
00001e  e036              B        |L5.142|
                  |L5.32|
;;;309        }
;;;310        else if (uart_chl == 2)
000020  2c02              CMP      r4,#2
000022  d10a              BNE      |L5.58|
;;;311        {
;;;312            uart_gpio_init(uart_chl);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       uart_gpio_init
;;;313            uart_config(uart_chl, uart_bound);
00002a  4629              MOV      r1,r5
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       uart_config
;;;314    		uart_irq_set(uart_chl);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       uart_irq_set
000038  e029              B        |L5.142|
                  |L5.58|
;;;315        }
;;;316        else if (uart_chl == 3)
00003a  2c03              CMP      r4,#3
00003c  d10a              BNE      |L5.84|
;;;317        {
;;;318            uart_gpio_init( uart_chl);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       uart_gpio_init
;;;319            uart_config(uart_chl, uart_bound);
000044  4629              MOV      r1,r5
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       uart_config
;;;320    		uart_irq_set(uart_chl);
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       uart_irq_set
000052  e01c              B        |L5.142|
                  |L5.84|
;;;321        }
;;;322        else if (uart_chl == 4)
000054  2c04              CMP      r4,#4
000056  d10a              BNE      |L5.110|
;;;323        {
;;;324            uart_gpio_init(uart_chl);
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       uart_gpio_init
;;;325            uart_config(uart_chl, uart_bound);
00005e  4629              MOV      r1,r5
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       uart_config
;;;326    		uart_irq_set(uart_chl);
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       uart_irq_set
00006c  e00f              B        |L5.142|
                  |L5.110|
;;;327        }
;;;328        else if (uart_chl == 5)
00006e  2c05              CMP      r4,#5
000070  d10a              BNE      |L5.136|
;;;329        {
;;;330            uart_gpio_init(uart_chl);
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       uart_gpio_init
;;;331            uart_config(uart_chl, uart_bound);
000078  4629              MOV      r1,r5
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       uart_config
;;;332    		uart_irq_set(uart_chl);
000080  4620              MOV      r0,r4
000082  f7fffffe          BL       uart_irq_set
000086  e002              B        |L5.142|
                  |L5.136|
;;;333        }
;;;334        else 
;;;335        {
;;;336            printf("error! \r\n");
000088  a001              ADR      r0,|L5.144|
00008a  f7fffffe          BL       __2printf
                  |L5.142|
;;;337        }
;;;338    }
00008e  bd70              POP      {r4-r6,pc}
;;;339    
                          ENDP

                  |L5.144|
000090  6572726f          DCB      "error! \r\n",0
000094  7221200d
000098  0a00    
00009a  00                DCB      0
00009b  00                DCB      0

                          AREA ||i.uart_irq_set||, CODE, READONLY, ALIGN=2

                  uart_irq_set PROC
;;;231    //-------------------------------------------------------------------------------------------------------------------------
;;;232    static void uart_irq_set(uint8_t uart_chl)
000000  b538              PUSH     {r3-r5,lr}
;;;233    {
000002  4604              MOV      r4,r0
;;;234    	NVIC_InitTypeDef uart_nvic_config = {0};
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;235    
;;;236    	if (uart_chl == 1)
000008  2c01              CMP      r4,#1
00000a  d114              BNE      |L6.54|
;;;237        {
;;;238            uart_nvic_config.NVIC_IRQChannel 					= USART1_IRQn;
00000c  2025              MOVS     r0,#0x25
00000e  f88d0000          STRB     r0,[sp,#0]
;;;239    		uart_nvic_config.NVIC_IRQChannelPreemptionPriority 	= 3 ;//抢占优先级3
000012  2003              MOVS     r0,#3
000014  f88d0001          STRB     r0,[sp,#1]
;;;240    		uart_nvic_config.NVIC_IRQChannelSubPriority 		= 3;		//子优先级3
000018  f88d0002          STRB     r0,[sp,#2]
;;;241    		uart_nvic_config.NVIC_IRQChannelCmd 				= ENABLE;			//IRQ通道使能
00001c  2001              MOVS     r0,#1
00001e  f88d0003          STRB     r0,[sp,#3]
;;;242    		NVIC_Init(&uart_nvic_config);	//根据指定的参数初始化NVIC寄存器
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       NVIC_Init
;;;243    
;;;244    		USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启串口接受中断
000028  2201              MOVS     r2,#1
00002a  f2405125          MOV      r1,#0x525
00002e  4830              LDR      r0,|L6.240|
000030  f7fffffe          BL       USART_ITConfig
000034  e05a              B        |L6.236|
                  |L6.54|
;;;245        }
;;;246        else if (uart_chl == 2)
000036  2c02              CMP      r4,#2
000038  d114              BNE      |L6.100|
;;;247        {
;;;248            uart_nvic_config.NVIC_IRQChannel 					= USART2_IRQn;
00003a  2026              MOVS     r0,#0x26
00003c  f88d0000          STRB     r0,[sp,#0]
;;;249    		uart_nvic_config.NVIC_IRQChannelPreemptionPriority 	= 3 ;//抢占优先级3
000040  2003              MOVS     r0,#3
000042  f88d0001          STRB     r0,[sp,#1]
;;;250    		uart_nvic_config.NVIC_IRQChannelSubPriority 		= 3;		//子优先级3
000046  f88d0002          STRB     r0,[sp,#2]
;;;251    		uart_nvic_config.NVIC_IRQChannelCmd 				= ENABLE;			//IRQ通道使能
00004a  2001              MOVS     r0,#1
00004c  f88d0003          STRB     r0,[sp,#3]
;;;252    		NVIC_Init(&uart_nvic_config);	//根据指定的参数初始化NVIC寄存器
000050  4668              MOV      r0,sp
000052  f7fffffe          BL       NVIC_Init
;;;253    
;;;254    		USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);//开启串口接受中断
000056  2201              MOVS     r2,#1
000058  f2405125          MOV      r1,#0x525
00005c  4825              LDR      r0,|L6.244|
00005e  f7fffffe          BL       USART_ITConfig
000062  e043              B        |L6.236|
                  |L6.100|
;;;255        }
;;;256        else if (uart_chl == 3)
000064  2c03              CMP      r4,#3
000066  d114              BNE      |L6.146|
;;;257        {
;;;258            uart_nvic_config.NVIC_IRQChannel 					= USART3_IRQn;
000068  2027              MOVS     r0,#0x27
00006a  f88d0000          STRB     r0,[sp,#0]
;;;259    		uart_nvic_config.NVIC_IRQChannelPreemptionPriority 	= 3 ;//抢占优先级3
00006e  2003              MOVS     r0,#3
000070  f88d0001          STRB     r0,[sp,#1]
;;;260    		uart_nvic_config.NVIC_IRQChannelSubPriority 		= 3;		//子优先级3
000074  f88d0002          STRB     r0,[sp,#2]
;;;261    		uart_nvic_config.NVIC_IRQChannelCmd 				= ENABLE;			//IRQ通道使能
000078  2001              MOVS     r0,#1
00007a  f88d0003          STRB     r0,[sp,#3]
;;;262    		NVIC_Init(&uart_nvic_config);	//根据指定的参数初始化NVIC寄存器
00007e  4668              MOV      r0,sp
000080  f7fffffe          BL       NVIC_Init
;;;263    
;;;264    		USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);//开启串口接受中断
000084  2201              MOVS     r2,#1
000086  f2405125          MOV      r1,#0x525
00008a  481b              LDR      r0,|L6.248|
00008c  f7fffffe          BL       USART_ITConfig
000090  e02c              B        |L6.236|
                  |L6.146|
;;;265        }
;;;266        else if (uart_chl == 4)
000092  2c04              CMP      r4,#4
000094  d114              BNE      |L6.192|
;;;267        {
;;;268            uart_nvic_config.NVIC_IRQChannel 					= UART4_IRQn;
000096  2034              MOVS     r0,#0x34
000098  f88d0000          STRB     r0,[sp,#0]
;;;269    		uart_nvic_config.NVIC_IRQChannelPreemptionPriority 	= 3 ;//抢占优先级3
00009c  2003              MOVS     r0,#3
00009e  f88d0001          STRB     r0,[sp,#1]
;;;270    		uart_nvic_config.NVIC_IRQChannelSubPriority 		= 3;		//子优先级3
0000a2  f88d0002          STRB     r0,[sp,#2]
;;;271    		uart_nvic_config.NVIC_IRQChannelCmd 				= ENABLE;			//IRQ通道使能
0000a6  2001              MOVS     r0,#1
0000a8  f88d0003          STRB     r0,[sp,#3]
;;;272    		NVIC_Init(&uart_nvic_config);	//根据指定的参数初始化NVIC寄存器
0000ac  4668              MOV      r0,sp
0000ae  f7fffffe          BL       NVIC_Init
;;;273    
;;;274    		USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);//开启串口接受中断
0000b2  2201              MOVS     r2,#1
0000b4  f2405125          MOV      r1,#0x525
0000b8  4810              LDR      r0,|L6.252|
0000ba  f7fffffe          BL       USART_ITConfig
0000be  e015              B        |L6.236|
                  |L6.192|
;;;275        }
;;;276        else if (uart_chl == 5)
0000c0  2c05              CMP      r4,#5
0000c2  d113              BNE      |L6.236|
;;;277        {
;;;278            uart_nvic_config.NVIC_IRQChannel 					= UART5_IRQn;
0000c4  2035              MOVS     r0,#0x35
0000c6  f88d0000          STRB     r0,[sp,#0]
;;;279    		uart_nvic_config.NVIC_IRQChannelPreemptionPriority 	= 3 ;//抢占优先级3
0000ca  2003              MOVS     r0,#3
0000cc  f88d0001          STRB     r0,[sp,#1]
;;;280    		uart_nvic_config.NVIC_IRQChannelSubPriority 			= 3;		//子优先级3
0000d0  f88d0002          STRB     r0,[sp,#2]
;;;281    		uart_nvic_config.NVIC_IRQChannelCmd 				= ENABLE;			//IRQ通道使能
0000d4  2001              MOVS     r0,#1
0000d6  f88d0003          STRB     r0,[sp,#3]
;;;282    		NVIC_Init(&uart_nvic_config);	//根据指定的参数初始化NVIC寄存器
0000da  4668              MOV      r0,sp
0000dc  f7fffffe          BL       NVIC_Init
;;;283    
;;;284    		USART_ITConfig(UART5, USART_IT_RXNE, ENABLE);//开启串口接受中断
0000e0  2201              MOVS     r2,#1
0000e2  f2405125          MOV      r1,#0x525
0000e6  4806              LDR      r0,|L6.256|
0000e8  f7fffffe          BL       USART_ITConfig
                  |L6.236|
;;;285        }
;;;286        else 
;;;287        {
;;;288    //        printf("error! \r\n");
;;;289        }
;;;290    }
0000ec  bd38              POP      {r3-r5,pc}
;;;291    
                          ENDP

0000ee  0000              DCW      0x0000
                  |L6.240|
                          DCD      0x40013800
                  |L6.244|
                          DCD      0x40004400
                  |L6.248|
                          DCD      0x40004800
                  |L6.252|
                          DCD      0x40004c00
                  |L6.256|
                          DCD      0x40005000

                          AREA ||i.uart_recv_byte||, CODE, READONLY, ALIGN=2

                  uart_recv_byte PROC
;;;430    //-------------------------------------------------------------------------------------------------------------------------
;;;431    uint8_t uart_recv_byte(uint8_t uart_chl)
000000  b570              PUSH     {r4-r6,lr}
;;;432    {
000002  4604              MOV      r4,r0
;;;433    	uint8_t recv_byte = 0;
000004  2500              MOVS     r5,#0
;;;434    
;;;435    	if (uart_chl == 1)
000006  2c01              CMP      r4,#1
000008  d10b              BNE      |L7.34|
;;;436        {
;;;437    	#if 1
;;;438    		while((USART1->SR & 0X20) == 0);//循环发送,直到发送完毕   
00000a  bf00              NOP      
                  |L7.12|
00000c  4823              LDR      r0,|L7.156|
00000e  8800              LDRH     r0,[r0,#0]
000010  f0000020          AND      r0,r0,#0x20
000014  2800              CMP      r0,#0
000016  d0f9              BEQ      |L7.12|
;;;439    		recv_byte = USART1->DR; 
000018  4820              LDR      r0,|L7.156|
00001a  1d00              ADDS     r0,r0,#4
00001c  8800              LDRH     r0,[r0,#0]
00001e  b2c5              UXTB     r5,r0
000020  e03a              B        |L7.152|
                  |L7.34|
;;;440    	#else
;;;441    		while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);	//等待串口接收标志位置位
;;;442    		recv_byte = USART_ReceiveData(USART1);	//接收数据
;;;443    
;;;444    	#endif
;;;445        }
;;;446        else if (uart_chl == 2)
000022  2c02              CMP      r4,#2
000024  d10b              BNE      |L7.62|
;;;447        {
;;;448    		while (USART_GetFlagStatus(USART2, USART_FLAG_RXNE) == RESET);	//等待串口接收标志位置位
000026  bf00              NOP      
                  |L7.40|
000028  2120              MOVS     r1,#0x20
00002a  481d              LDR      r0,|L7.160|
00002c  f7fffffe          BL       USART_GetFlagStatus
000030  2800              CMP      r0,#0
000032  d0f9              BEQ      |L7.40|
;;;449    		recv_byte = USART_ReceiveData(USART2);	//接收数据
000034  481a              LDR      r0,|L7.160|
000036  f7fffffe          BL       USART_ReceiveData
00003a  b2c5              UXTB     r5,r0
00003c  e02c              B        |L7.152|
                  |L7.62|
;;;450        }
;;;451        else if (uart_chl == 3)
00003e  2c03              CMP      r4,#3
000040  d10b              BNE      |L7.90|
;;;452        {
;;;453    		while (USART_GetFlagStatus(USART3, USART_FLAG_RXNE) == RESET);	//等待串口接收标志位置位
000042  bf00              NOP      
                  |L7.68|
000044  2120              MOVS     r1,#0x20
000046  4817              LDR      r0,|L7.164|
000048  f7fffffe          BL       USART_GetFlagStatus
00004c  2800              CMP      r0,#0
00004e  d0f9              BEQ      |L7.68|
;;;454    		recv_byte = USART_ReceiveData(USART3);	//接收数据
000050  4814              LDR      r0,|L7.164|
000052  f7fffffe          BL       USART_ReceiveData
000056  b2c5              UXTB     r5,r0
000058  e01e              B        |L7.152|
                  |L7.90|
;;;455        }
;;;456        else if (uart_chl == 4)
00005a  2c04              CMP      r4,#4
00005c  d10b              BNE      |L7.118|
;;;457        {
;;;458    		while (USART_GetFlagStatus(UART4, USART_FLAG_RXNE) == RESET);	//等待串口接收标志位置位
00005e  bf00              NOP      
                  |L7.96|
000060  2120              MOVS     r1,#0x20
000062  4811              LDR      r0,|L7.168|
000064  f7fffffe          BL       USART_GetFlagStatus
000068  2800              CMP      r0,#0
00006a  d0f9              BEQ      |L7.96|
;;;459    		recv_byte = USART_ReceiveData(UART4);	//接收数据
00006c  480e              LDR      r0,|L7.168|
00006e  f7fffffe          BL       USART_ReceiveData
000072  b2c5              UXTB     r5,r0
000074  e010              B        |L7.152|
                  |L7.118|
;;;460        }
;;;461        else if (uart_chl == 5)
000076  2c05              CMP      r4,#5
000078  d10b              BNE      |L7.146|
;;;462        {
;;;463    		while (USART_GetFlagStatus(UART5, USART_FLAG_RXNE) == RESET);	//等待串口接收标志位置位
00007a  bf00              NOP      
                  |L7.124|
00007c  2120              MOVS     r1,#0x20
00007e  480b              LDR      r0,|L7.172|
000080  f7fffffe          BL       USART_GetFlagStatus
000084  2800              CMP      r0,#0
000086  d0f9              BEQ      |L7.124|
;;;464    		recv_byte = USART_ReceiveData(UART5);	//接收数据
000088  4808              LDR      r0,|L7.172|
00008a  f7fffffe          BL       USART_ReceiveData
00008e  b2c5              UXTB     r5,r0
000090  e002              B        |L7.152|
                  |L7.146|
;;;465        }
;;;466        else 
;;;467        {
;;;468            printf("error! \r\n");
000092  a007              ADR      r0,|L7.176|
000094  f7fffffe          BL       __2printf
                  |L7.152|
;;;469        }
;;;470    	
;;;471    	return recv_byte;
000098  4628              MOV      r0,r5
;;;472    }
00009a  bd70              POP      {r4-r6,pc}
;;;473    
                          ENDP

                  |L7.156|
                          DCD      0x40013800
                  |L7.160|
                          DCD      0x40004400
                  |L7.164|
                          DCD      0x40004800
                  |L7.168|
                          DCD      0x40004c00
                  |L7.172|
                          DCD      0x40005000
                  |L7.176|
0000b0  6572726f          DCB      "error! \r\n",0
0000b4  7221200d
0000b8  0a00    
0000ba  00                DCB      0
0000bb  00                DCB      0

                          AREA ||i.uart_recv_serial_bytes||, CODE, READONLY, ALIGN=1

                  uart_recv_serial_bytes PROC
;;;484    //-------------------------------------------------------------------------------------------------------------------------
;;;485    bool uart_recv_serial_bytes(uint8_t uart_chl, uint8_t *pbdata, uint16_t length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;486    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;487    	for (uint16_t i = 0; i < length; i++)
00000a  2600              MOVS     r6,#0
00000c  e006              B        |L8.28|
                  |L8.14|
;;;488    	{
;;;489    		*pbdata++ = uart_recv_byte(1);
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       uart_recv_byte
000014  f8040b01          STRB     r0,[r4],#1
000018  1c70              ADDS     r0,r6,#1              ;487
00001a  b286              UXTH     r6,r0                 ;487
                  |L8.28|
00001c  42ae              CMP      r6,r5                 ;487
00001e  dbf6              BLT      |L8.14|
;;;490    	}
;;;491    	
;;;492    	return true;
000020  2001              MOVS     r0,#1
;;;493    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;494    
                          ENDP


                          AREA ||i.uart_send_byte||, CODE, READONLY, ALIGN=2

                  uart_send_byte PROC
;;;349    //-------------------------------------------------------------------------------------------------------------------------
;;;350    bool uart_send_byte(uint8_t uart_chl, uint8_t send_byte)
000000  b570              PUSH     {r4-r6,lr}
;;;351    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;352    	if (uart_chl == 1)
000006  2c01              CMP      r4,#1
000008  d10b              BNE      |L9.34|
;;;353        {
;;;354    	#if 0
;;;355    		while((USART1->SR & 0X40) == 0);//循环发送,直到发送完毕   
;;;356    		USART1->DR = (uint8_t)send_byte; 
;;;357    	#else
;;;358    		while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET);	//等待串口发送标志位置位
00000a  bf00              NOP      
                  |L9.12|
00000c  2140              MOVS     r1,#0x40
00000e  4823              LDR      r0,|L9.156|
000010  f7fffffe          BL       USART_GetFlagStatus
000014  2800              CMP      r0,#0
000016  d0f9              BEQ      |L9.12|
;;;359    
;;;360    		USART_SendData(USART1, (uint8_t)send_byte);	//发送数据
000018  4629              MOV      r1,r5
00001a  4820              LDR      r0,|L9.156|
00001c  f7fffffe          BL       USART_SendData
000020  e03a              B        |L9.152|
                  |L9.34|
;;;361    
;;;362    	#endif
;;;363        }
;;;364        else if (uart_chl == 2)
000022  2c02              CMP      r4,#2
000024  d10b              BNE      |L9.62|
;;;365        {
;;;366    		while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET);	//等待串口发送标志位置位
000026  bf00              NOP      
                  |L9.40|
000028  2140              MOVS     r1,#0x40
00002a  481d              LDR      r0,|L9.160|
00002c  f7fffffe          BL       USART_GetFlagStatus
000030  2800              CMP      r0,#0
000032  d0f9              BEQ      |L9.40|
;;;367    
;;;368    		USART_SendData(USART2, (uint8_t)send_byte);	//发送数据
000034  4629              MOV      r1,r5
000036  481a              LDR      r0,|L9.160|
000038  f7fffffe          BL       USART_SendData
00003c  e02c              B        |L9.152|
                  |L9.62|
;;;369        }
;;;370        else if (uart_chl == 3)
00003e  2c03              CMP      r4,#3
000040  d10b              BNE      |L9.90|
;;;371        {
;;;372    		while(USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET);	//等待串口发送标志位置位
000042  bf00              NOP      
                  |L9.68|
000044  2140              MOVS     r1,#0x40
000046  4817              LDR      r0,|L9.164|
000048  f7fffffe          BL       USART_GetFlagStatus
00004c  2800              CMP      r0,#0
00004e  d0f9              BEQ      |L9.68|
;;;373    
;;;374    		USART_SendData(USART3, (uint8_t)send_byte);	//发送数据
000050  4629              MOV      r1,r5
000052  4814              LDR      r0,|L9.164|
000054  f7fffffe          BL       USART_SendData
000058  e01e              B        |L9.152|
                  |L9.90|
;;;375        }
;;;376        else if (uart_chl == 4)
00005a  2c04              CMP      r4,#4
00005c  d10b              BNE      |L9.118|
;;;377        {
;;;378    		while(USART_GetFlagStatus(UART4, USART_FLAG_TC) == RESET);	//等待串口发送标志位置位
00005e  bf00              NOP      
                  |L9.96|
000060  2140              MOVS     r1,#0x40
000062  4811              LDR      r0,|L9.168|
000064  f7fffffe          BL       USART_GetFlagStatus
000068  2800              CMP      r0,#0
00006a  d0f9              BEQ      |L9.96|
;;;379    
;;;380    		USART_SendData(UART4, (uint8_t)send_byte);	//发送数据
00006c  4629              MOV      r1,r5
00006e  480e              LDR      r0,|L9.168|
000070  f7fffffe          BL       USART_SendData
000074  e010              B        |L9.152|
                  |L9.118|
;;;381        }
;;;382        else if (uart_chl == 5)
000076  2c05              CMP      r4,#5
000078  d10b              BNE      |L9.146|
;;;383        {
;;;384    		while(USART_GetFlagStatus(UART5, USART_FLAG_TC) == RESET);	//等待串口发送标志位置位
00007a  bf00              NOP      
                  |L9.124|
00007c  2140              MOVS     r1,#0x40
00007e  480b              LDR      r0,|L9.172|
000080  f7fffffe          BL       USART_GetFlagStatus
000084  2800              CMP      r0,#0
000086  d0f9              BEQ      |L9.124|
;;;385    
;;;386    		USART_SendData(UART5, (uint8_t)send_byte);	//发送数据
000088  4629              MOV      r1,r5
00008a  4808              LDR      r0,|L9.172|
00008c  f7fffffe          BL       USART_SendData
000090  e002              B        |L9.152|
                  |L9.146|
;;;387        }
;;;388        else 
;;;389        {
;;;390            printf("error! \r\n");
000092  a007              ADR      r0,|L9.176|
000094  f7fffffe          BL       __2printf
                  |L9.152|
;;;391        }
;;;392    
;;;393    	return true;
000098  2001              MOVS     r0,#1
;;;394    }
00009a  bd70              POP      {r4-r6,pc}
;;;395    
                          ENDP

                  |L9.156|
                          DCD      0x40013800
                  |L9.160|
                          DCD      0x40004400
                  |L9.164|
                          DCD      0x40004800
                  |L9.168|
                          DCD      0x40004c00
                  |L9.172|
                          DCD      0x40005000
                  |L9.176|
0000b0  6572726f          DCB      "error! \r\n",0
0000b4  7221200d
0000b8  0a00    
0000ba  00                DCB      0
0000bb  00                DCB      0

                          AREA ||i.uart_send_serial_bytes||, CODE, READONLY, ALIGN=1

                  uart_send_serial_bytes PROC
;;;406    //-------------------------------------------------------------------------------------------------------------------------
;;;407    bool uart_send_serial_bytes(uint8_t uart_chl, uint8_t *pbdata, uint16_t length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;408    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;409    	for (uint16_t i = 0; i < length; i++)
00000a  2400              MOVS     r4,#0
00000c  e005              B        |L10.26|
                  |L10.14|
;;;410    	{
;;;411    		uart_send_byte(uart_chl, pbdata[i]);
00000e  5d29              LDRB     r1,[r5,r4]
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       uart_send_byte
000016  1c60              ADDS     r0,r4,#1              ;409
000018  b284              UXTH     r4,r0                 ;409
                  |L10.26|
00001a  42b4              CMP      r4,r6                 ;409
00001c  dbf7              BLT      |L10.14|
;;;412    	}
;;;413    	
;;;414    	// while (length--)
;;;415    	// {
;;;416    	// 	uart_send_byte(uart_chl, *pbdata++);
;;;417    	// }
;;;418    
;;;419    	return true;
00001e  2001              MOVS     r0,#1
;;;420    }
000020  e8bd81f0          POP      {r4-r8,pc}
;;;421    
                          ENDP


                          AREA ||i.uart_test||, CODE, READONLY, ALIGN=2

                  uart_test PROC
;;;524    //-------------------------------------------------------------------------------------------------------------------------
;;;525    void uart_test(void)
000000  b51f              PUSH     {r0-r4,lr}
;;;526    {
;;;527    	uint8_t tmp_buff[6] = {0};
000002  2000              MOVS     r0,#0
000004  9002              STR      r0,[sp,#8]
000006  9003              STR      r0,[sp,#0xc]
;;;528    	uint8_t err_flag[6] = "error";
000008  a10c              ADR      r1,|L11.60|
00000a  c903              LDM      r1,{r0,r1}
00000c  e9cd0100          STRD     r0,r1,[sp,#0]
;;;529    
;;;530    	uart_recv_serial_bytes(1, tmp_buff, sizeof(tmp_buff));
000010  2206              MOVS     r2,#6
000012  a902              ADD      r1,sp,#8
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       uart_recv_serial_bytes
;;;531    
;;;532    	if (tmp_buff[0] == 0x55)
00001a  f89d0008          LDRB     r0,[sp,#8]
00001e  2855              CMP      r0,#0x55
000020  d105              BNE      |L11.46|
;;;533    	{
;;;534    		uart_send_serial_bytes(1, tmp_buff, sizeof(tmp_buff));
000022  2206              MOVS     r2,#6
000024  a902              ADD      r1,sp,#8
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       uart_send_serial_bytes
00002c  e004              B        |L11.56|
                  |L11.46|
;;;535    	}
;;;536    	else
;;;537    	{
;;;538    		uart_send_serial_bytes(1, err_flag, 6);
00002e  2206              MOVS     r2,#6
000030  4669              MOV      r1,sp
000032  2001              MOVS     r0,#1
000034  f7fffffe          BL       uart_send_serial_bytes
                  |L11.56|
;;;539    	}
;;;540    }
000038  bd1f              POP      {r0-r4,pc}
;;;541    #endif /* __PRJ_STM32F10X_DRVUART_C__ */
                          ENDP

00003a  0000              DCW      0x0000
                  |L11.60|
00003c  6572726f          DCB      "error",0
000040  7200    
000042  00                DCB      0
000043  00                DCB      0
