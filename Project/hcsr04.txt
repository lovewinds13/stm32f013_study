; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\hcsr04.o --asm_dir=.\ --list_dir=.\ --depend=.\hcsr04.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\App\inc -I..\Driver\inc -I..\Libraries\CMSIS\Core\inc -I..\Libraries\CMSIS\Device\inc -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\HalIterface\inc -I..\User\inc -I..\Driver\src -ID:\KEIL_ARM_PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\keil_arm\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=533 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\hcsr04.crf ..\Driver\src\hcsr04.c]
                          THUMB

                          AREA ||i.TIM4_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM4_IRQHandler PROC
;;;87     
;;;88     void TIM4_IRQHandler(void)
000000  492d              LDR      r1,|L1.184|
;;;89     {
;;;90     	u16 sta_val;
;;;91     	
;;;92     	sta_val = TIM4->SR;
000002  8808              LDRH     r0,[r1,#0]
;;;93     	if ((g_cap_state & 0X80) == 0X00)	//未捕获
000004  492d              LDR      r1,|L1.188|
000006  7809              LDRB     r1,[r1,#0]  ; g_cap_state
000008  f0010180          AND      r1,r1,#0x80
00000c  2900              CMP      r1,#0
00000e  d14e              BNE      |L1.174|
;;;94     	{
;;;95     		if (sta_val & 0X01)	//溢出
000010  f0000101          AND      r1,r0,#1
000014  b1d1              CBZ      r1,|L1.76|
;;;96     		{
;;;97     			if (g_cap_state & 0X40)	//捕获到高电平
000016  4929              LDR      r1,|L1.188|
000018  7809              LDRB     r1,[r1,#0]  ; g_cap_state
00001a  f0010140          AND      r1,r1,#0x40
00001e  b1a9              CBZ      r1,|L1.76|
;;;98     			{
;;;99     				if ((g_cap_state & 0X3f) == 0X3f)	//高电平时间过长
000020  4926              LDR      r1,|L1.188|
000022  7809              LDRB     r1,[r1,#0]  ; g_cap_state
000024  f001013f          AND      r1,r1,#0x3f
000028  293f              CMP      r1,#0x3f
00002a  d10a              BNE      |L1.66|
;;;100    				{
;;;101    					g_cap_state |= 0X80;	//记录一次捕获
00002c  4923              LDR      r1,|L1.188|
00002e  8809              LDRH     r1,[r1,#0]  ; g_cap_state
000030  f0410180          ORR      r1,r1,#0x80
000034  4a21              LDR      r2,|L1.188|
000036  8011              STRH     r1,[r2,#0]
;;;102    					g_cap_val = 0Xffff;	//溢出时间
000038  f64f71ff          MOV      r1,#0xffff
00003c  4a20              LDR      r2,|L1.192|
00003e  8011              STRH     r1,[r2,#0]
000040  e004              B        |L1.76|
                  |L1.66|
;;;103    				}
;;;104    				else 
;;;105    				{
;;;106    					g_cap_state++;	//继续捕获
000042  491e              LDR      r1,|L1.188|
000044  8809              LDRH     r1,[r1,#0]  ; g_cap_state
000046  1c49              ADDS     r1,r1,#1
000048  4a1c              LDR      r2,|L1.188|
00004a  8011              STRH     r1,[r2,#0]
                  |L1.76|
;;;107    				}
;;;108    			}
;;;109    		}
;;;110    		
;;;111    		if (sta_val & 0X08) //捕获3(通道3)发生捕获事件
00004c  f0000108          AND      r1,r0,#8
000050  b369              CBZ      r1,|L1.174|
;;;112    		{
;;;113    			if (g_cap_state & 0X40)	//捕获下降沿
000052  491a              LDR      r1,|L1.188|
000054  7809              LDRB     r1,[r1,#0]  ; g_cap_state
000056  f0010140          AND      r1,r1,#0x40
00005a  b199              CBZ      r1,|L1.132|
;;;114    			{
;;;115    				g_cap_state |= 0X80;	//标记成功捕获一次高电平
00005c  4917              LDR      r1,|L1.188|
00005e  8809              LDRH     r1,[r1,#0]  ; g_cap_state
000060  f0410180          ORR      r1,r1,#0x80
000064  4a15              LDR      r2,|L1.188|
000066  8011              STRH     r1,[r2,#0]
;;;116    				g_cap_val = TIM4->CCR3;	//获取当前捕获值
000068  4913              LDR      r1,|L1.184|
00006a  312c              ADDS     r1,r1,#0x2c
00006c  8809              LDRH     r1,[r1,#0]
00006e  4a14              LDR      r2,|L1.192|
000070  8011              STRH     r1,[r2,#0]
;;;117    				TIM4->CCER &= ~(1<<9);	//CC1P=0 设置为上升沿捕获
000072  4911              LDR      r1,|L1.184|
000074  3110              ADDS     r1,r1,#0x10
000076  8809              LDRH     r1,[r1,#0]
000078  f4217100          BIC      r1,r1,#0x200
00007c  4a0e              LDR      r2,|L1.184|
00007e  3210              ADDS     r2,r2,#0x10
000080  8011              STRH     r1,[r2,#0]
000082  e014              B        |L1.174|
                  |L1.132|
;;;118    			}
;;;119    			else 
;;;120    			{
;;;121    				g_cap_state = 0;
000084  2100              MOVS     r1,#0
000086  4a0d              LDR      r2,|L1.188|
000088  8011              STRH     r1,[r2,#0]
;;;122    				g_cap_val = 0;
00008a  4a0d              LDR      r2,|L1.192|
00008c  8011              STRH     r1,[r2,#0]
;;;123    				g_cap_state |= 0X40;	//标记捕获到上升沿
00008e  490b              LDR      r1,|L1.188|
000090  8809              LDRH     r1,[r1,#0]  ; g_cap_state
000092  f0410140          ORR      r1,r1,#0x40
000096  4a09              LDR      r2,|L1.188|
000098  8011              STRH     r1,[r2,#0]
;;;124    				TIM4->CNT = 0;	//清空计数器
00009a  2100              MOVS     r1,#0
00009c  4a06              LDR      r2,|L1.184|
00009e  3214              ADDS     r2,r2,#0x14
0000a0  8011              STRH     r1,[r2,#0]
;;;125    				TIM4->CCER |= (1<<9);	//CC1P=1 设置为下降沿捕获
0000a2  1f11              SUBS     r1,r2,#4
0000a4  8809              LDRH     r1,[r1,#0]
0000a6  f4417100          ORR      r1,r1,#0x200
0000aa  1f12              SUBS     r2,r2,#4
0000ac  8011              STRH     r1,[r2,#0]
                  |L1.174|
;;;126    			}
;;;127    		}
;;;128    	}
;;;129    	
;;;130    	TIM4->SR = 0;	//清除中断标志位
0000ae  2100              MOVS     r1,#0
0000b0  4a01              LDR      r2,|L1.184|
0000b2  8011              STRH     r1,[r2,#0]
;;;131    }
0000b4  4770              BX       lr
                          ENDP

0000b6  0000              DCW      0x0000
                  |L1.184|
                          DCD      0x40000810
                  |L1.188|
                          DCD      g_cap_state
                  |L1.192|
                          DCD      g_cap_val

                          AREA ||i.hcsr04_read_distance||, CODE, READONLY, ALIGN=2

                  hcsr04_read_distance PROC
;;;71     //---------------------------------------------------------------------------------------------------------------------------------------------
;;;72     void hcsr04_read_distance(void)
000000  b510              PUSH     {r4,lr}
;;;73     {
;;;74     	GPIO_SetBits(GPIOB, GPIO_Pin_9);	//启动超声波测量
000002  f44f7100          MOV      r1,#0x200
000006  4818              LDR      r0,|L2.104|
000008  f7fffffe          BL       GPIO_SetBits
;;;75     	delay_us(15);
00000c  200f              MOVS     r0,#0xf
00000e  f7fffffe          BL       delay_us
;;;76     	GPIO_ResetBits(GPIOB, GPIO_Pin_9);
000012  f44f7100          MOV      r1,#0x200
000016  4814              LDR      r0,|L2.104|
000018  f7fffffe          BL       GPIO_ResetBits
;;;77     	
;;;78     	if (g_cap_state & 0X80)	//捕获一次高电平
00001c  4813              LDR      r0,|L2.108|
00001e  7800              LDRB     r0,[r0,#0]  ; g_cap_state
000020  f0000080          AND      r0,r0,#0x80
000024  b1f0              CBZ      r0,|L2.100|
;;;79     	{
;;;80     		g_cap_distance = g_cap_state & 0X3f;
000026  4811              LDR      r0,|L2.108|
000028  7800              LDRB     r0,[r0,#0]  ; g_cap_state
00002a  f000003f          AND      r0,r0,#0x3f
00002e  4910              LDR      r1,|L2.112|
000030  6008              STR      r0,[r1,#0]  ; g_cap_distance
;;;81     		g_cap_distance *= 65535;
000032  4608              MOV      r0,r1
000034  6800              LDR      r0,[r0,#0]  ; g_cap_distance
000036  ebc04000          RSB      r0,r0,r0,LSL #16
00003a  6008              STR      r0,[r1,#0]  ; g_cap_distance
;;;82     		g_cap_distance += g_cap_val;
00003c  4608              MOV      r0,r1
00003e  6800              LDR      r0,[r0,#0]  ; g_cap_distance
000040  490c              LDR      r1,|L2.116|
000042  8809              LDRH     r1,[r1,#0]  ; g_cap_val
000044  4408              ADD      r0,r0,r1
000046  490a              LDR      r1,|L2.112|
000048  6008              STR      r0,[r1,#0]  ; g_cap_distance
;;;83     		g_cap_distance = g_cap_distance * 170 / 1000;	//计算距离(mm)
00004a  4608              MOV      r0,r1
00004c  6800              LDR      r0,[r0,#0]  ; g_cap_distance
00004e  21aa              MOVS     r1,#0xaa
000050  4348              MULS     r0,r1,r0
000052  f44f717a          MOV      r1,#0x3e8
000056  fbb0f0f1          UDIV     r0,r0,r1
00005a  4905              LDR      r1,|L2.112|
00005c  6008              STR      r0,[r1,#0]  ; g_cap_distance
;;;84     		g_cap_state = 0X00;
00005e  2000              MOVS     r0,#0
000060  4902              LDR      r1,|L2.108|
000062  8008              STRH     r0,[r1,#0]
                  |L2.100|
;;;85     	}
;;;86     }
000064  bd10              POP      {r4,pc}
;;;87     
                          ENDP

000066  0000              DCW      0x0000
                  |L2.104|
                          DCD      0x40010c00
                  |L2.108|
                          DCD      g_cap_state
                  |L2.112|
                          DCD      g_cap_distance
                  |L2.116|
                          DCD      g_cap_val

                          AREA ||i.timer4_cap_init||, CODE, READONLY, ALIGN=2

                  timer4_cap_init PROC
;;;18     //---------------------------------------------------------------------------------------------------------------------------------------------
;;;19     void timer4_cap_init(u16 timer_arr, u16 timer_psc)
000000  b530              PUSH     {r4,r5,lr}
;;;20     {
000002  b085              SUB      sp,sp,#0x14
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;21     	GPIO_InitTypeDef gp_init;
;;;22     	TIM_TimeBaseInitTypeDef  tim_base_init;
;;;23     	NVIC_InitTypeDef nvic_init_config;
;;;24     
;;;25     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);	//使能TIM2时钟
000008  2101              MOVS     r1,#1
00000a  2004              MOVS     r0,#4
00000c  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;26     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);  //使能GPIOB时钟
000010  2101              MOVS     r1,#1
000012  2008              MOVS     r0,#8
000014  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;27     
;;;28     	gp_init.GPIO_Pin  	= GPIO_Pin_8; 
000018  f44f7080          MOV      r0,#0x100
00001c  f8ad0010          STRH     r0,[sp,#0x10]
;;;29     	gp_init.GPIO_Mode 	= GPIO_Mode_IPD; //PB8 输入 (ECHO) 
000020  2028              MOVS     r0,#0x28
000022  f88d0013          STRB     r0,[sp,#0x13]
;;;30     	GPIO_Init(GPIOB, &gp_init);
000026  a904              ADD      r1,sp,#0x10
000028  4821              LDR      r0,|L3.176|
00002a  f7fffffe          BL       GPIO_Init
;;;31     
;;;32     	gp_init.GPIO_Pin  	= GPIO_Pin_9;     
00002e  f44f7000          MOV      r0,#0x200
000032  f8ad0010          STRH     r0,[sp,#0x10]
;;;33     	gp_init.GPIO_Mode 	= GPIO_Mode_Out_PP;     //PB9 输出 (TRIG)
000036  2010              MOVS     r0,#0x10
000038  f88d0013          STRB     r0,[sp,#0x13]
;;;34     	gp_init.GPIO_Speed 	= GPIO_Speed_2MHz;     //2M
00003c  2002              MOVS     r0,#2
00003e  f88d0012          STRB     r0,[sp,#0x12]
;;;35     	GPIO_Init(GPIOB, &gp_init);
000042  a904              ADD      r1,sp,#0x10
000044  481a              LDR      r0,|L3.176|
000046  f7fffffe          BL       GPIO_Init
;;;36     
;;;37     	//初始化定时器4 TIM4	 
;;;38     	tim_base_init.TIM_Period 		= timer_arr; //设定计数器自动重装值 
00004a  f8ad5008          STRH     r5,[sp,#8]
;;;39     	tim_base_init.TIM_Prescaler 	= timer_psc; 	//预分频器   
00004e  f8ad4004          STRH     r4,[sp,#4]
;;;40     	tim_base_init.TIM_ClockDivision = TIM_CKD_DIV1; //设置时钟分割:TDTS = Tck_tim
000052  2000              MOVS     r0,#0
000054  f8ad000a          STRH     r0,[sp,#0xa]
;;;41     	tim_base_init.TIM_CounterMode 	= TIM_CounterMode_Up;  //TIM向上计数模式
000058  f8ad0006          STRH     r0,[sp,#6]
;;;42     	TIM_TimeBaseInit(TIM4, &tim_base_init); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位
00005c  a901              ADD      r1,sp,#4
00005e  4815              LDR      r0,|L3.180|
000060  f7fffffe          BL       TIM_TimeBaseInit
;;;43     
;;;44     	//初始化TIM4输入捕获参数
;;;45     	tim_ic_init.TIM_Channel 	= TIM_Channel_3; //CC1S=03 	选择输入端 IC3映射到TI1上
000064  2008              MOVS     r0,#8
000066  4914              LDR      r1,|L3.184|
000068  8008              STRH     r0,[r1,#0]
;;;46     	tim_ic_init.TIM_ICPolarity 	= TIM_ICPolarity_Rising;	//上升沿捕获
00006a  2000              MOVS     r0,#0
00006c  8048              STRH     r0,[r1,#2]
;;;47     	tim_ic_init.TIM_ICSelection = TIM_ICSelection_DirectTI;
00006e  2001              MOVS     r0,#1
000070  8088              STRH     r0,[r1,#4]
;;;48     	tim_ic_init.TIM_ICPrescaler = TIM_ICPSC_DIV1;	 //配置输入分频,不分频 
000072  2000              MOVS     r0,#0
000074  80c8              STRH     r0,[r1,#6]
;;;49     	tim_ic_init.TIM_ICFilter 	= 0x00;//配置输入滤波器 不滤波
000076  8108              STRH     r0,[r1,#8]
;;;50     	TIM_ICInit(TIM4, &tim_ic_init);
000078  480e              LDR      r0,|L3.180|
00007a  f7fffffe          BL       TIM_ICInit
;;;51     
;;;52     	//中断分组初始化
;;;53     	nvic_init_config.NVIC_IRQChannel 					= TIM4_IRQn;  //TIM4中断
00007e  201e              MOVS     r0,#0x1e
000080  f88d0000          STRB     r0,[sp,#0]
;;;54     	nvic_init_config.NVIC_IRQChannelPreemptionPriority 	= 3;  //先占优先级2级
000084  2003              MOVS     r0,#3
000086  f88d0001          STRB     r0,[sp,#1]
;;;55     	nvic_init_config.NVIC_IRQChannelSubPriority 		= 3;  //从优先级0级
00008a  f88d0002          STRB     r0,[sp,#2]
;;;56     	nvic_init_config.NVIC_IRQChannelCmd 				= ENABLE; //IRQ通道被使能
00008e  2001              MOVS     r0,#1
000090  f88d0003          STRB     r0,[sp,#3]
;;;57     	NVIC_Init(&nvic_init_config);  //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器 	
000094  4668              MOV      r0,sp
000096  f7fffffe          BL       NVIC_Init
;;;58     	
;;;59     	TIM_ITConfig(TIM4, TIM_IT_Update|TIM_IT_CC3, ENABLE);//允许更新中断 ,允许CC3IE捕获中断	
00009a  2201              MOVS     r2,#1
00009c  2109              MOVS     r1,#9
00009e  4805              LDR      r0,|L3.180|
0000a0  f7fffffe          BL       TIM_ITConfig
;;;60     	TIM_Cmd(TIM4, ENABLE); 	//使能定时器3
0000a4  2101              MOVS     r1,#1
0000a6  4803              LDR      r0,|L3.180|
0000a8  f7fffffe          BL       TIM_Cmd
;;;61     }
0000ac  b005              ADD      sp,sp,#0x14
0000ae  bd30              POP      {r4,r5,pc}
;;;62     
                          ENDP

                  |L3.176|
                          DCD      0x40010c00
                  |L3.180|
                          DCD      0x40000800
                  |L3.184|
                          DCD      tim_ic_init

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  tim_ic_init
                          %        10

                          AREA ||.data||, DATA, ALIGN=2

                  g_cap_state
000000  0000              DCB      0x00,0x00
                  g_cap_val
000002  0000              DCB      0x00,0x00
                  g_cap_distance
                          DCD      0x00000000
