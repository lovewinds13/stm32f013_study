; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\hardware_spi.o --asm_dir=.\ --list_dir=.\ --depend=.\hardware_spi.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\App\inc -I..\Driver\inc -I..\Libraries\CMSIS\Core\inc -I..\Libraries\CMSIS\Device\inc -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\HalIterface\inc -I..\User\inc -I..\Driver\src -ID:\KEIL_ARM_PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\keil_arm\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=533 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\hardware_spi.crf ..\Driver\src\hardware_spi.c]
                          THUMB

                          AREA ||i.SFLASH_ReadID||, CODE, READONLY, ALIGN=2

                  SFLASH_ReadID PROC
;;;403    
;;;404    uint16_t SFLASH_ReadID(void)
000000  b510              PUSH     {r4,lr}
;;;405    {
;;;406      uint16_t ID = 0;
000002  2400              MOVS     r4,#0
;;;407       FLASH_CS_0();                              //使能器件
000004  2104              MOVS     r1,#4
000006  4812              LDR      r0,|L1.80|
000008  f7fffffe          BL       GPIO_ResetBits
;;;408    
;;;409    //  SPI_WriteReadByte(90);           //《设备ID》指令
;;;410    //  SPI_WriteReadByte(0x00);
;;;411    //  SPI_WriteReadByte(0x00);
;;;412    //  SPI_WriteReadByte(0x00);
;;;413    	
;;;414    //	SPI1_ReadWriteByte(0x90);//发送读取ID命令	    
;;;415    //	SPI1_ReadWriteByte(0x00); 	    
;;;416    //	SPI1_ReadWriteByte(0x00); 	    
;;;417    //	SPI1_ReadWriteByte(0x00); 
;;;418    
;;;419    //  ID |= SPI_WriteReadByte(0xFF)<<8;              //读取ID
;;;420    //  ID |= SPI_WriteReadByte(0xFF);
;;;421    	
;;;422    
;;;423    //	spi_master_send_byte(1, 0x90);//发送读取ID命令	    
;;;424    //	spi_master_send_byte(1, 0x00); 	    
;;;425    //	spi_master_send_byte(1, 0x00); 	    
;;;426    //	spi_master_send_byte(1, 0x00); 
;;;427    
;;;428    //	ID |= spi_master_recv_byte(0xFF)<<8;              //读取ID
;;;429    //	ID |= spi_master_recv_byte(0xFF);
;;;430    
;;;431    	spi_master_send_recv_byte(1, 0x90);//发送读取ID命令	    
00000c  2190              MOVS     r1,#0x90
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       spi_master_send_recv_byte
;;;432    	spi_master_send_recv_byte(1, 0x00); 	    
000014  2100              MOVS     r1,#0
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       spi_master_send_recv_byte
;;;433    	spi_master_send_recv_byte(1, 0x00); 	    
00001c  2100              MOVS     r1,#0
00001e  2001              MOVS     r0,#1
000020  f7fffffe          BL       spi_master_send_recv_byte
;;;434    	spi_master_send_recv_byte(1, 0x00); 
000024  2100              MOVS     r1,#0
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       spi_master_send_recv_byte
;;;435    
;;;436    	ID |= spi_master_send_recv_byte(1, 0xFF)<<8;              //读取ID
00002c  21ff              MOVS     r1,#0xff
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       spi_master_send_recv_byte
000034  ea442400          ORR      r4,r4,r0,LSL #8
;;;437    	ID |= spi_master_send_recv_byte(1, 0xFF);
000038  21ff              MOVS     r1,#0xff
00003a  2001              MOVS     r0,#1
00003c  f7fffffe          BL       spi_master_send_recv_byte
000040  4304              ORRS     r4,r4,r0
;;;438      
;;;439       FLASH_CS_1();                             //失能器件
000042  2104              MOVS     r1,#4
000044  4802              LDR      r0,|L1.80|
000046  f7fffffe          BL       GPIO_SetBits
;;;440    	
;;;441      return ID;
00004a  4620              MOV      r0,r4
;;;442    }
00004c  bd10              POP      {r4,pc}
;;;443    
                          ENDP

00004e  0000              DCW      0x0000
                  |L1.80|
                          DCD      0x40010800

                          AREA ||i.SPI1_IRQHandler||, CODE, READONLY, ALIGN=2

                  SPI1_IRQHandler PROC
;;;374    //-------------------------------------------------------------------------------------------------------
;;;375    void SPI1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;376    {
;;;377    	uint16_t i = 0;
000002  2400              MOVS     r4,#0
;;;378    	
;;;379    	if (SPI_I2S_GetITStatus(SPI1, SPI_I2S_IT_RXNE) != RESET)	//产生接收中断
000004  2160              MOVS     r1,#0x60
000006  4810              LDR      r0,|L2.72|
000008  f7fffffe          BL       SPI_I2S_GetITStatus
00000c  b1d0              CBZ      r0,|L2.68|
;;;380    	{
;;;381    		SPI_I2S_ClearITPendingBit(SPI1, SPI_I2S_IT_RXNE);	//清除中断标志
00000e  2160              MOVS     r1,#0x60
000010  480d              LDR      r0,|L2.72|
000012  f7fffffe          BL       SPI_I2S_ClearITPendingBit
;;;382    		SPI_I2S_ITConfig(SPI1, SPI_I2S_IT_RXNE, DISABLE);	//禁止中断使能
000016  2200              MOVS     r2,#0
000018  2160              MOVS     r1,#0x60
00001a  480b              LDR      r0,|L2.72|
00001c  f7fffffe          BL       SPI_I2S_ITConfig
;;;383    		for (i = 0; i < g_SpiTxRxLen; i++)
000020  bf00              NOP      
000022  e006              B        |L2.50|
                  |L2.36|
;;;384    		{
;;;385    //			while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
;;;386    			g_DataTmpBuffer[i] = (uint8_t)SPI_I2S_ReceiveData(SPI1);	//接收数据
000024  4808              LDR      r0,|L2.72|
000026  f7fffffe          BL       SPI_I2S_ReceiveData
00002a  4908              LDR      r1,|L2.76|
00002c  5508              STRB     r0,[r1,r4]
00002e  1c60              ADDS     r0,r4,#1              ;383
000030  b284              UXTH     r4,r0                 ;383
                  |L2.50|
000032  4807              LDR      r0,|L2.80|
000034  8800              LDRH     r0,[r0,#0]            ;383  ; g_SpiTxRxLen
000036  4284              CMP      r4,r0                 ;383
000038  dbf4              BLT      |L2.36|
;;;387    		}
;;;388    		SPI_I2S_ITConfig(SPI1, SPI_I2S_IT_RXNE, ENABLE);	//重新使能中断
00003a  2201              MOVS     r2,#1
00003c  2160              MOVS     r1,#0x60
00003e  4802              LDR      r0,|L2.72|
000040  f7fffffe          BL       SPI_I2S_ITConfig
                  |L2.68|
;;;389    	}
;;;390    }
000044  bd10              POP      {r4,pc}
;;;391    
                          ENDP

000046  0000              DCW      0x0000
                  |L2.72|
                          DCD      0x40013000
                  |L2.76|
                          DCD      g_DataTmpBuffer
                  |L2.80|
                          DCD      g_SpiTxRxLen

                          AREA ||i.SPI1_ReadWriteByte||, CODE, READONLY, ALIGN=2

                  SPI1_ReadWriteByte PROC
;;;443    
;;;444    uint8_t SPI1_ReadWriteByte(u8 TxData)
000000  b570              PUSH     {r4-r6,lr}
;;;445    {		
000002  4605              MOV      r5,r0
;;;446    	u8 retry=0;				 	
000004  2400              MOVS     r4,#0
;;;447    	while (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET) //检查指定的SPI标志位设置与否:发送缓存空标志位
000006  e005              B        |L3.20|
                  |L3.8|
;;;448    		{
;;;449    		retry++;
000008  1c60              ADDS     r0,r4,#1
00000a  b2c4              UXTB     r4,r0
;;;450    		if(retry>200)return 0;
00000c  2cc8              CMP      r4,#0xc8
00000e  dd01              BLE      |L3.20|
000010  2000              MOVS     r0,#0
                  |L3.18|
;;;451    		}			  
;;;452    	SPI_I2S_SendData(SPI1, TxData); //通过外设SPIx发送一个数据
;;;453    	retry=0;
;;;454    
;;;455    	while (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET)//检查指定的SPI标志位设置与否:接受缓存非空标志位
;;;456    		{
;;;457    		retry++;
;;;458    		if(retry>200)return 0;
;;;459    		}	  						    
;;;460    	return SPI_I2S_ReceiveData(SPI1); //返回通过SPIx最近接收的数据					    
;;;461    }
000012  bd70              POP      {r4-r6,pc}
                  |L3.20|
000014  2102              MOVS     r1,#2                 ;447
000016  480e              LDR      r0,|L3.80|
000018  f7fffffe          BL       SPI_I2S_GetFlagStatus
00001c  2800              CMP      r0,#0                 ;447
00001e  d0f3              BEQ      |L3.8|
000020  4629              MOV      r1,r5                 ;452
000022  480b              LDR      r0,|L3.80|
000024  f7fffffe          BL       SPI_I2S_SendData
000028  2400              MOVS     r4,#0                 ;453
00002a  e005              B        |L3.56|
                  |L3.44|
00002c  1c60              ADDS     r0,r4,#1              ;457
00002e  b2c4              UXTB     r4,r0                 ;457
000030  2cc8              CMP      r4,#0xc8              ;458
000032  dd01              BLE      |L3.56|
000034  2000              MOVS     r0,#0                 ;458
000036  e7ec              B        |L3.18|
                  |L3.56|
000038  2101              MOVS     r1,#1                 ;455
00003a  4805              LDR      r0,|L3.80|
00003c  f7fffffe          BL       SPI_I2S_GetFlagStatus
000040  2800              CMP      r0,#0                 ;455
000042  d0f3              BEQ      |L3.44|
000044  4802              LDR      r0,|L3.80|
000046  f7fffffe          BL       SPI_I2S_ReceiveData
00004a  b2c0              UXTB     r0,r0                 ;460
00004c  e7e1              B        |L3.18|
;;;462    
                          ENDP

00004e  0000              DCW      0x0000
                  |L3.80|
                          DCD      0x40013000

                          AREA ||i.SPI_Flash_ReadID||, CODE, READONLY, ALIGN=2

                  SPI_Flash_ReadID PROC
;;;462    
;;;463    uint16_t SPI_Flash_ReadID(void)
000000  b510              PUSH     {r4,lr}
;;;464    {
;;;465    	u16 Temp = 0;	  
000002  2400              MOVS     r4,#0
;;;466    	 FLASH_CS_0();			    
000004  2104              MOVS     r1,#4
000006  480f              LDR      r0,|L4.68|
000008  f7fffffe          BL       GPIO_ResetBits
;;;467    	SPI1_ReadWriteByte(0x90);//发送读取ID命令	    
00000c  2090              MOVS     r0,#0x90
00000e  f7fffffe          BL       SPI1_ReadWriteByte
;;;468    	SPI1_ReadWriteByte(0x00); 	    
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       SPI1_ReadWriteByte
;;;469    	SPI1_ReadWriteByte(0x00); 	    
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       SPI1_ReadWriteByte
;;;470    	SPI1_ReadWriteByte(0x00); 	 			   
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       SPI1_ReadWriteByte
;;;471    	Temp|=SPI1_ReadWriteByte(0xFF)<<8;  
000024  20ff              MOVS     r0,#0xff
000026  f7fffffe          BL       SPI1_ReadWriteByte
00002a  ea442400          ORR      r4,r4,r0,LSL #8
;;;472    	Temp|=SPI1_ReadWriteByte(0xFF);	 
00002e  20ff              MOVS     r0,#0xff
000030  f7fffffe          BL       SPI1_ReadWriteByte
000034  4304              ORRS     r4,r4,r0
;;;473    	 FLASH_CS_1();				    
000036  2104              MOVS     r1,#4
000038  4802              LDR      r0,|L4.68|
00003a  f7fffffe          BL       GPIO_SetBits
;;;474    	return Temp;
00003e  4620              MOV      r0,r4
;;;475    }  
000040  bd10              POP      {r4,pc}
;;;476    
                          ENDP

000042  0000              DCW      0x0000
                  |L4.68|
                          DCD      0x40010800

                          AREA ||i.SPI_WriteReadByte||, CODE, READONLY, ALIGN=2

                  SPI_WriteReadByte PROC
;;;394    
;;;395    uint8_t SPI_WriteReadByte(uint8_t TxData)
000000  4601              MOV      r1,r0
;;;396    {
;;;397      while((SPI1->SR & SPI_I2S_FLAG_TXE) == (uint16_t)RESET);
000002  bf00              NOP      
                  |L5.4|
000004  4809              LDR      r0,|L5.44|
000006  8900              LDRH     r0,[r0,#8]
000008  f0000002          AND      r0,r0,#2
00000c  2800              CMP      r0,#0
00000e  d0f9              BEQ      |L5.4|
;;;398      SPI1->DR = TxData;
000010  4806              LDR      r0,|L5.44|
000012  8181              STRH     r1,[r0,#0xc]
;;;399    
;;;400      while((SPI1->SR & SPI_I2S_FLAG_RXNE) == (uint16_t)RESET);
000014  bf00              NOP      
                  |L5.22|
000016  4805              LDR      r0,|L5.44|
000018  8900              LDRH     r0,[r0,#8]
00001a  f0000001          AND      r0,r0,#1
00001e  2800              CMP      r0,#0
000020  d0f9              BEQ      |L5.22|
;;;401      return SPI1->DR;
000022  4802              LDR      r0,|L5.44|
000024  8980              LDRH     r0,[r0,#0xc]
000026  b2c0              UXTB     r0,r0
;;;402    }
000028  4770              BX       lr
;;;403    
                          ENDP

00002a  0000              DCW      0x0000
                  |L5.44|
                          DCD      0x40013000

                          AREA ||i.spi_flash_gpio_init||, CODE, READONLY, ALIGN=2

                  spi_flash_gpio_init PROC
;;;29     //--------------------------------------------------------------------------------------------------------
;;;30     void spi_flash_gpio_init(void)
000000  b508              PUSH     {r3,lr}
;;;31     {
;;;32     	GPIO_InitTypeDef gpio_config_init;
;;;33     
;;;34     #if 0	//调试CS硬件方式
;;;35     	RCC_APB2PeriphClockCmd(RCC_PCLK_SPIM1_GPIO, ENABLE);		//开启SPIM1 GPIO时钟
;;;36     
;;;37     	gpio_config_init.GPIO_Pin 	= FLASH_CS_IO;	//SPIM1_CLK_IO IO初始化
;;;38     	gpio_config_init.GPIO_Mode 	= GPIO_Mode_Out_PP;  //复用推挽输出
;;;39     	gpio_config_init.GPIO_Speed = GPIO_Speed_50MHz;
;;;40     	GPIO_Init(SPIM1_GPIO_PORT, &gpio_config_init);
;;;41     
;;;42     	GPIO_SetBits(SPIM1_GPIO_PORT, FLASH_CS_IO);	//IO初始状态都设置为高电平
;;;43     #else
;;;44     	RCC_APB2PeriphClockCmd(RCC_PCLK_SPIM1_GPIO, ENABLE);		//开启SPIM1 GPIO时钟
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;45     
;;;46     	gpio_config_init.GPIO_Pin 	= FLASH_CS;	//SPIM1_CLK_IO IO初始化
00000a  2004              MOVS     r0,#4
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;47     	gpio_config_init.GPIO_Mode 	= GPIO_Mode_Out_PP;  //复用推挽输出
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;48     	gpio_config_init.GPIO_Speed = GPIO_Speed_50MHz;
000016  2003              MOVS     r0,#3
000018  f88d0002          STRB     r0,[sp,#2]
;;;49     	GPIO_Init(SPIM1_GPIO_PORT, &gpio_config_init);
00001c  4669              MOV      r1,sp
00001e  4804              LDR      r0,|L6.48|
000020  f7fffffe          BL       GPIO_Init
;;;50     
;;;51     	GPIO_SetBits(SPIM1_GPIO_PORT, FLASH_CS);	//IO初始状态都设置为高电平
000024  2104              MOVS     r1,#4
000026  4802              LDR      r0,|L6.48|
000028  f7fffffe          BL       GPIO_SetBits
;;;52     #endif
;;;53     }
00002c  bd08              POP      {r3,pc}
;;;54     
                          ENDP

00002e  0000              DCW      0x0000
                  |L6.48|
                          DCD      0x40010800

                          AREA ||i.spi_flash_read_id||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_x
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                  spi_flash_read_id PROC
;;;318    
;;;319    uint32_t spi_flash_read_id(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;320    {
;;;321    	uint32_t ulJedId = 0;
000002  2500              MOVS     r5,#0
;;;322    	uint8_t recv_buff[5] = {0};
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  9001              STR      r0,[sp,#4]
;;;323    	
;;;324    	 FLASH_CS_0();
00000a  2104              MOVS     r1,#4
00000c  4815              LDR      r0,|L7.100|
00000e  f7fffffe          BL       GPIO_ResetBits
;;;325    
;;;326    #if 0
;;;327    	 spi_master_send_recv_byte(1, FLASH_READ_JEDEC_ID);	//9fh
;;;328    	 ulJedId |= spi_master_send_recv_byte(1, 0xFF)<<16;
;;;329    	 ulJedId |= spi_master_send_recv_byte(1, 0xFF)<<8;
;;;330    	 ulJedId |= spi_master_send_recv_byte(1, 0xFF);
;;;331    #endif
;;;332    	
;;;333    #if 1
;;;334    	spi_master_send_recv_byte(1, FLASH_READ_JEDEC_ID);	//9fh
000012  219f              MOVS     r1,#0x9f
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       spi_master_send_recv_byte
;;;335    	 
;;;336    	spi_master_recv_some_bytes(1, recv_buff, sizeof(recv_buff));
00001a  2205              MOVS     r2,#5
00001c  4669              MOV      r1,sp
00001e  2001              MOVS     r0,#1
000020  f7fffffe          BL       spi_master_recv_some_bytes
;;;337    	
;;;338    	ulJedId = (recv_buff[0] <<16) | (recv_buff[1] <<8) | (recv_buff[2]);
000024  f89d0000          LDRB     r0,[sp,#0]
000028  0400              LSLS     r0,r0,#16
00002a  f89d1001          LDRB     r1,[sp,#1]
00002e  ea402001          ORR      r0,r0,r1,LSL #8
000032  f89d1002          LDRB     r1,[sp,#2]
000036  ea400501          ORR      r5,r0,r1
;;;339    	
;;;340    //	spi_master_send_byte(1, 0xff);
;;;341    //	recv_buff[0] = spi_master_recv_byte(1);
;;;342    //	spi_master_send_byte(1, 0xff);
;;;343    //	recv_buff[1] = spi_master_recv_byte(1);
;;;344    //	spi_master_send_byte(1, 0xff);
;;;345    //	recv_buff[2] = spi_master_recv_byte(1);
;;;346    //	spi_master_send_byte(1, 0xff);
;;;347    //	recv_buff[3] = spi_master_recv_byte(1);
;;;348    //	spi_master_send_byte(1, 0xff);
;;;349    //	recv_buff[4] = spi_master_recv_byte(1);
;;;350    	
;;;351    	for (uint16_t i = 0; i < sizeof(recv_buff); i++)
00003a  2400              MOVS     r4,#0
00003c  e007              B        |L7.78|
                  |L7.62|
;;;352    	{
;;;353    		printf("recv ---> %d 0x%02X \r\n", i, recv_buff[i]);
00003e  f81d2004          LDRB     r2,[sp,r4]
000042  4621              MOV      r1,r4
000044  a008              ADR      r0,|L7.104|
000046  f7fffffe          BL       __2printf
00004a  1c60              ADDS     r0,r4,#1              ;351
00004c  b284              UXTH     r4,r0                 ;351
                  |L7.78|
00004e  2c05              CMP      r4,#5                 ;351
000050  d3f5              BCC      |L7.62|
;;;354    	}
;;;355    	printf("\r\n");
000052  a00a              ADR      r0,|L7.124|
000054  f7fffffe          BL       __2printf
;;;356    	
;;;357    #endif
;;;358    
;;;359    	 FLASH_CS_1();
000058  2104              MOVS     r1,#4
00005a  4802              LDR      r0,|L7.100|
00005c  f7fffffe          BL       GPIO_SetBits
;;;360    	
;;;361    	return ulJedId;
000060  4628              MOV      r0,r5
;;;362    }
000062  bd7c              POP      {r2-r6,pc}
;;;363    
                          ENDP

                  |L7.100|
                          DCD      0x40010800
                  |L7.104|
000068  72656376          DCB      "recv ---> %d 0x%02X "
00006c  202d2d2d
000070  3e202564
000074  20307825
000078  30325820
                  |L7.124|
00007c  0d0a00            DCB      "\r\n",0
00007f  00                DCB      0

                          AREA ||i.spi_gpio_init||, CODE, READONLY, ALIGN=2

                  spi_gpio_init PROC
;;;63     //--------------------------------------------------------------------------------------------------------
;;;64     void spi_gpio_init(uint8_t spi_chl)
000000  b538              PUSH     {r3-r5,lr}
;;;65     {
000002  4604              MOV      r4,r0
;;;66     	GPIO_InitTypeDef gpio_config_init;
;;;67     
;;;68     	if (spi_chl == 1)
000004  2c01              CMP      r4,#1
000006  d121              BNE      |L8.76|
;;;69     	{
;;;70     		RCC_APB2PeriphClockCmd(RCC_PCLK_SPIM1_GPIO, ENABLE);		//开启SPIM1 GPIO时钟、
000008  2101              MOVS     r1,#1
00000a  2004              MOVS     r0,#4
00000c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;71     		
;;;72     //		gpio_config_init.GPIO_Pin 		= SPIM1_CLK_IO | SPIM1_MISO_IO | SPIM1_MOSI_IO;	//SPIM1_CLK_IO IO初始化
;;;73     		gpio_config_init.GPIO_Pin 		= SPIM1_CLK_IO | SPIM1_MOSI_IO;
000010  20a0              MOVS     r0,#0xa0
000012  f8ad0000          STRH     r0,[sp,#0]
;;;74     		gpio_config_init.GPIO_Mode 		= GPIO_Mode_AF_PP;  //复用推挽输出
000016  2018              MOVS     r0,#0x18
000018  f88d0003          STRB     r0,[sp,#3]
;;;75     		gpio_config_init.GPIO_Speed 	= GPIO_Speed_50MHz;
00001c  2003              MOVS     r0,#3
00001e  f88d0002          STRB     r0,[sp,#2]
;;;76     		
;;;77     		GPIO_Init(SPIM1_GPIO_PORT, &gpio_config_init);
000022  4669              MOV      r1,sp
000024  480a              LDR      r0,|L8.80|
000026  f7fffffe          BL       GPIO_Init
;;;78     		
;;;79     		gpio_config_init.GPIO_Pin 		= SPIM1_MISO_IO;	//SPIM1_MISO_IO IO初始化
00002a  2040              MOVS     r0,#0x40
00002c  f8ad0000          STRH     r0,[sp,#0]
;;;80     		gpio_config_init.GPIO_Mode 		= GPIO_Mode_IN_FLOATING;  //MISO浮空输入
000030  2004              MOVS     r0,#4
000032  f88d0003          STRB     r0,[sp,#3]
;;;81     		gpio_config_init.GPIO_Speed 	= GPIO_Speed_50MHz;
000036  2003              MOVS     r0,#3
000038  f88d0002          STRB     r0,[sp,#2]
;;;82     		GPIO_Init(SPIM1_GPIO_PORT, &gpio_config_init);
00003c  4669              MOV      r1,sp
00003e  4804              LDR      r0,|L8.80|
000040  f7fffffe          BL       GPIO_Init
;;;83     
;;;84     		GPIO_SetBits(SPIM1_GPIO_PORT, SPIM1_CLK_IO | SPIM1_MISO_IO | SPIM1_MOSI_IO);	//IO初始状态都设置为高电平
000044  21e0              MOVS     r1,#0xe0
000046  4802              LDR      r0,|L8.80|
000048  f7fffffe          BL       GPIO_SetBits
                  |L8.76|
;;;85     	}		
;;;86     }
00004c  bd38              POP      {r3-r5,pc}
;;;87     
                          ENDP

00004e  0000              DCW      0x0000
                  |L8.80|
                          DCD      0x40010800

                          AREA ||i.spi_master_init||, CODE, READONLY, ALIGN=2

                  spi_master_init PROC
;;;96     //--------------------------------------------------------------------------------------------------------
;;;97     void spi_master_init(uint8_t spi_chl)
000000  b510              PUSH     {r4,lr}
;;;98     {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;99     	SPI_InitTypeDef  spi_config_init;
;;;100    #if 1  
;;;101    	if(spi_chl == 1)
000006  2c01              CMP      r4,#1
000008  d12a              BNE      |L9.96|
;;;102    	{	
;;;103    		spi_flash_gpio_init();	//spi flash cs 初始化
00000a  f7fffffe          BL       spi_flash_gpio_init
;;;104    //		sd_gpio_init();	//spi sd cs 初始化
;;;105    //		nrf24l01_gpio_init();//spi nrf24l01 cs 初始化
;;;106    		
;;;107    		spi_gpio_init(1);	//spi gpio 初始化
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       spi_gpio_init
;;;108    
;;;109    		RCC_APB2PeriphClockCmd(RCC_PCLK_SPIM1_HD, ENABLE);	//SPI1时钟使能
000014  2101              MOVS     r1,#1
000016  0308              LSLS     r0,r1,#12
000018  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;110    
;;;111    		spi_config_init.SPI_Direction 			= SPI_Direction_2Lines_FullDuplex;  //设置SPI单向或者双向的数据模式:SPI设置为双线双向全双工
00001c  2000              MOVS     r0,#0
00001e  f8ad0004          STRH     r0,[sp,#4]
;;;112    		spi_config_init.SPI_Mode 				= SPI_Mode_Master;		//设置SPI工作模式:设置为主SPI
000022  f44f7082          MOV      r0,#0x104
000026  f8ad0006          STRH     r0,[sp,#6]
;;;113    		spi_config_init.SPI_DataSize 			= SPI_DataSize_8b;		//设置SPI的数据大小:SPI发送接收8位帧结构
00002a  2000              MOVS     r0,#0
00002c  f8ad0008          STRH     r0,[sp,#8]
;;;114    		spi_config_init.SPI_CPOL 				= SPI_CPOL_Low;		//选择了串行时钟的稳态:空闲时钟低
000030  f8ad000a          STRH     r0,[sp,#0xa]
;;;115    		spi_config_init.SPI_CPHA 				= SPI_CPHA_1Edge;	//数据捕获(采样)于第1个时钟沿
000034  f8ad000c          STRH     r0,[sp,#0xc]
;;;116    		spi_config_init.SPI_NSS					= SPI_NSS_Soft;//SPI_NSS_Soft;		//NSS信号由硬件（NSS管脚）还是软件（使用SSI位）管理:内部NSS信号有SSI位控制
000038  0260              LSLS     r0,r4,#9
00003a  f8ad000e          STRH     r0,[sp,#0xe]
;;;117    		spi_config_init.SPI_BaudRatePrescaler 	= SPI_BaudRatePrescaler_256;		//定义波特率预分频的值:波特率预分频值为256
00003e  2038              MOVS     r0,#0x38
000040  f8ad0010          STRH     r0,[sp,#0x10]
;;;118    		spi_config_init.SPI_FirstBit 			= SPI_FirstBit_MSB;	//指定数据传输从MSB位还是LSB位开始:数据传输从MSB位开始
000044  2000              MOVS     r0,#0
000046  f8ad0012          STRH     r0,[sp,#0x12]
;;;119    		spi_config_init.SPI_CRCPolynomial 		= 7;	//CRC值计算的多项式
00004a  2007              MOVS     r0,#7
00004c  f8ad0014          STRH     r0,[sp,#0x14]
;;;120    		
;;;121    		SPI_Init(SPI1, &spi_config_init);  //根据SPI_InitStruct中指定的参数初始化外设SPIx寄存器
000050  a901              ADD      r1,sp,#4
000052  4804              LDR      r0,|L9.100|
000054  f7fffffe          BL       SPI_Init
;;;122    	 
;;;123    		SPI_Cmd(SPI1, ENABLE); //使能SPI外设
000058  2101              MOVS     r1,#1
00005a  4802              LDR      r0,|L9.100|
00005c  f7fffffe          BL       SPI_Cmd
                  |L9.96|
;;;124    		
;;;125    //		spi_master_send_recv_byte(1, 0xFF);	//启动传输	
;;;126    	
;;;127    	}
;;;128    #endif
;;;129    } 
000060  b006              ADD      sp,sp,#0x18
000062  bd10              POP      {r4,pc}
;;;130    
                          ENDP

                  |L9.100|
                          DCD      0x40013000

                          AREA ||i.spi_master_nvic_set||, CODE, READONLY, ALIGN=2

                  spi_master_nvic_set PROC
;;;304    //--------------------------------------------------------------------------------------------------------
;;;305    void spi_master_nvic_set(void)
000000  b508              PUSH     {r3,lr}
;;;306    {
;;;307    	NVIC_InitTypeDef nvic_config_init;
;;;308    	
;;;309    	nvic_config_init.NVIC_IRQChannel 						= SPI1_IRQn;
000002  2023              MOVS     r0,#0x23
000004  f88d0000          STRB     r0,[sp,#0]
;;;310    	nvic_config_init.NVIC_IRQChannelPreemptionPriority 	= 2;
000008  2002              MOVS     r0,#2
00000a  f88d0001          STRB     r0,[sp,#1]
;;;311    	nvic_config_init.NVIC_IRQChannelSubPriority 			= 2;
00000e  f88d0002          STRB     r0,[sp,#2]
;;;312    	nvic_config_init.NVIC_IRQChannelCmd 					= ENABLE;
000012  2001              MOVS     r0,#1
000014  f88d0003          STRB     r0,[sp,#3]
;;;313    
;;;314    	NVIC_Init(&nvic_config_init);
000018  4668              MOV      r0,sp
00001a  f7fffffe          BL       NVIC_Init
;;;315    	
;;;316    	SPI_I2S_ITConfig(SPI1, SPI_I2S_IT_RXNE, ENABLE);	//开启SPI1主设备接收使能
00001e  2201              MOVS     r2,#1
000020  2160              MOVS     r1,#0x60
000022  4802              LDR      r0,|L10.44|
000024  f7fffffe          BL       SPI_I2S_ITConfig
;;;317    }
000028  bd08              POP      {r3,pc}
;;;318    
                          ENDP

00002a  0000              DCW      0x0000
                  |L10.44|
                          DCD      0x40013000

                          AREA ||i.spi_master_recv_some_bytes||, CODE, READONLY, ALIGN=1

                  spi_master_recv_some_bytes PROC
;;;283    //--------------------------------------------------------------------------------------------------------
;;;284    void spi_master_recv_some_bytes(uint8_t spi_chl, uint8_t *pbdata, uint16_t recv_length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;285    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;286    	uint8_t *temp_data = pbdata;
00000a  4626              MOV      r6,r4
;;;287    
;;;288    	while (recv_length--)
00000c  e005              B        |L11.26|
                  |L11.14|
;;;289    	{
;;;290    		*temp_data++ = spi_master_send_recv_byte(spi_chl, 0xFF);	//发送 0xff 为从设备提供时钟
00000e  21ff              MOVS     r1,#0xff
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       spi_master_send_recv_byte
000016  f8060b01          STRB     r0,[r6],#1
                  |L11.26|
00001a  1e28              SUBS     r0,r5,#0              ;288
00001c  f1a50101          SUB      r1,r5,#1              ;288
000020  b28d              UXTH     r5,r1                 ;288
000022  d1f4              BNE      |L11.14|
;;;291    	}
;;;292    	
;;;293    }
000024  e8bd81f0          POP      {r4-r8,pc}
;;;294    
                          ENDP


                          AREA ||i.spi_master_send_recv_byte||, CODE, READONLY, ALIGN=2

                  spi_master_send_recv_byte PROC
;;;140    //--------------------------------------------------------------------------------------------------------
;;;141    uint8_t spi_master_send_recv_byte(uint8_t spi_chl, uint8_t spi_byte)
000000  b570              PUSH     {r4-r6,lr}
;;;142    {		
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;143    	uint8_t time = 0;
000006  2400              MOVS     r4,#0
;;;144    	
;;;145    	if (spi_chl == 1)			    
000008  2d01              CMP      r5,#1
00000a  d123              BNE      |L12.84|
;;;146    	{
;;;147    		while (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET) //检查指定的SPI标志位设置与否:发送缓存空标志位
00000c  e005              B        |L12.26|
                  |L12.14|
;;;148    		{
;;;149    			time++;
00000e  1c60              ADDS     r0,r4,#1
000010  b2c4              UXTB     r4,r0
;;;150    			if(time>200)
000012  2cc8              CMP      r4,#0xc8
000014  dd01              BLE      |L12.26|
;;;151    			{
;;;152    				return false;
000016  2000              MOVS     r0,#0
                  |L12.24|
;;;153    			}
;;;154    		}			  
;;;155    		SPI_I2S_SendData(SPI1, spi_byte); //通过外设SPIx发送一个数据
;;;156    	
;;;157    		time = 0;
;;;158    
;;;159    		while (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET)//检查指定的SPI标志位设置与否:接受缓存非空标志位
;;;160    		{
;;;161    			time++;
;;;162    			if(time>200)
;;;163    			{
;;;164    				return false;
;;;165    			}
;;;166    		}	  						    
;;;167    			return SPI_I2S_ReceiveData(SPI1); //返回通过SPIx最近接收的数据	
;;;168    	}
;;;169    	else 
;;;170    	{
;;;171    		return false;
;;;172    	}
;;;173    }
000018  bd70              POP      {r4-r6,pc}
                  |L12.26|
00001a  2102              MOVS     r1,#2                 ;147
00001c  480e              LDR      r0,|L12.88|
00001e  f7fffffe          BL       SPI_I2S_GetFlagStatus
000022  2800              CMP      r0,#0                 ;147
000024  d0f3              BEQ      |L12.14|
000026  4631              MOV      r1,r6                 ;155
000028  480b              LDR      r0,|L12.88|
00002a  f7fffffe          BL       SPI_I2S_SendData
00002e  2400              MOVS     r4,#0                 ;157
000030  e005              B        |L12.62|
                  |L12.50|
000032  1c60              ADDS     r0,r4,#1              ;161
000034  b2c4              UXTB     r4,r0                 ;161
000036  2cc8              CMP      r4,#0xc8              ;162
000038  dd01              BLE      |L12.62|
00003a  2000              MOVS     r0,#0                 ;164
00003c  e7ec              B        |L12.24|
                  |L12.62|
00003e  2101              MOVS     r1,#1                 ;159
000040  4805              LDR      r0,|L12.88|
000042  f7fffffe          BL       SPI_I2S_GetFlagStatus
000046  2800              CMP      r0,#0                 ;159
000048  d0f3              BEQ      |L12.50|
00004a  4803              LDR      r0,|L12.88|
00004c  f7fffffe          BL       SPI_I2S_ReceiveData
000050  b2c0              UXTB     r0,r0                 ;167
000052  e7e1              B        |L12.24|
                  |L12.84|
000054  2000              MOVS     r0,#0                 ;171
000056  e7df              B        |L12.24|
;;;174    
                          ENDP

                  |L12.88|
                          DCD      0x40013000

                          AREA ||i.spi_master_send_some_bytes||, CODE, READONLY, ALIGN=1

                  spi_master_send_some_bytes PROC
;;;256    //--------------------------------------------------------------------------------------------------------
;;;257    void spi_master_send_some_bytes(uint8_t spi_chl, uint8_t *pbdata, uint16_t send_length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;258    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;259    	uint16_t i = 0;
00000a  2400              MOVS     r4,#0
;;;260    
;;;261    	for (i = 0; i < send_length; i++)
00000c  bf00              NOP      
00000e  e005              B        |L13.28|
                  |L13.16|
;;;262    	{
;;;263    		spi_master_send_recv_byte(spi_chl, pbdata[i]);
000010  5d29              LDRB     r1,[r5,r4]
000012  4638              MOV      r0,r7
000014  f7fffffe          BL       spi_master_send_recv_byte
000018  1c60              ADDS     r0,r4,#1              ;261
00001a  b284              UXTH     r4,r0                 ;261
                  |L13.28|
00001c  42b4              CMP      r4,r6                 ;261
00001e  dbf7              BLT      |L13.16|
;;;264    	}
;;;265    	
;;;266    //	while (send_length--)
;;;267    //	{
;;;268    //		spi_master_send_byte(spi_chl, *pbdata++);
;;;269    //	}
;;;270    	
;;;271    }
000020  e8bd81f0          POP      {r4-r8,pc}
;;;272    
                          ENDP


                          AREA ||i.spi_master_speed_set||, CODE, READONLY, ALIGN=2

                  spi_master_speed_set PROC
;;;188    //--------------------------------------------------------------------------------------------------------
;;;189    void spi_master_speed_set(uint8_t spi_chl, uint8_t spi_speed)
000000  b530              PUSH     {r4,r5,lr}
;;;190    {
000002  b085              SUB      sp,sp,#0x14
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;191    	SPI_InitTypeDef  spi_config_init;
;;;192    
;;;193    	if (spi_chl == 1)
000008  2d01              CMP      r5,#1
00000a  d109              BNE      |L14.32|
;;;194    	{
;;;195    		spi_config_init.SPI_BaudRatePrescaler = spi_speed ;
00000c  f8ad400c          STRH     r4,[sp,#0xc]
;;;196    
;;;197    		SPI_Init(SPI1, &spi_config_init);
000010  4669              MOV      r1,sp
000012  4804              LDR      r0,|L14.36|
000014  f7fffffe          BL       SPI_Init
;;;198    		SPI_Cmd(SPI1, ENABLE);
000018  2101              MOVS     r1,#1
00001a  4802              LDR      r0,|L14.36|
00001c  f7fffffe          BL       SPI_Cmd
                  |L14.32|
;;;199    	}
;;;200    } 
000020  b005              ADD      sp,sp,#0x14
000022  bd30              POP      {r4,r5,pc}
;;;201    #if 0
                          ENDP

                  |L14.36|
                          DCD      0x40013000
