; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\drvnrf2401.o --asm_dir=.\ --list_dir=.\ --depend=.\drvnrf2401.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\App\inc -I..\Driver\inc -I..\Libraries\CMSIS\Core\inc -I..\Libraries\CMSIS\Device\inc -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\HalIterface\inc -I..\User\inc -I..\Driver\src -ID:\KEIL_ARM_PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\keil_arm\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=533 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\drvnrf2401.crf ..\Driver\src\drvnrf2401.c]
                          THUMB

                          AREA ||i.nrf24l01_check_state||, CODE, READONLY, ALIGN=2

                  nrf24l01_check_state PROC
;;;295    //---------------------------------------------------------------------------------------------------------------------------------------------
;;;296    uint8_t nrf24l01_check_state(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;297    {
;;;298    	uint8_t buff[5]={0xa5, 0xa5, 0xa5, 0xa5, 0xa5};
000002  a110              ADR      r1,|L1.68|
000004  c903              LDM      r1,{r0,r1}
000006  e9cd0100          STRD     r0,r1,[sp,#0]
;;;299    	uint8_t i = 0;
00000a  2400              MOVS     r4,#0
;;;300    
;;;301    	nrf24l01_write_buff(W_REGISTER+TX_ADDR, buff, 5);//写入5字节的地址
00000c  2205              MOVS     r2,#5
00000e  4669              MOV      r1,sp
000010  2030              MOVS     r0,#0x30
000012  f7fffffe          BL       nrf24l01_write_buff
;;;302    	nrf24l01_read_buff(TX_ADDR, buff, 5);
000016  2205              MOVS     r2,#5
000018  4669              MOV      r1,sp
00001a  2010              MOVS     r0,#0x10
00001c  f7fffffe          BL       nrf24l01_read_buff
;;;303    	
;;;304    	for(i = 0; i < 5; i++)
000020  bf00              NOP      
000022  e006              B        |L1.50|
                  |L1.36|
;;;305    	{
;;;306    		if(buff[i] != 0xa5)
000024  f81d0004          LDRB     r0,[sp,r4]
000028  28a5              CMP      r0,#0xa5
00002a  d000              BEQ      |L1.46|
;;;307    		{
;;;308    			break;
00002c  e003              B        |L1.54|
                  |L1.46|
00002e  1c60              ADDS     r0,r4,#1              ;304
000030  b2c4              UXTB     r4,r0                 ;304
                  |L1.50|
000032  2c05              CMP      r4,#5                 ;304
000034  dbf6              BLT      |L1.36|
                  |L1.54|
000036  bf00              NOP      
;;;309    		}
;;;310    	}
;;;311    	
;;;312    	if(i != 5)
000038  2c05              CMP      r4,#5
00003a  d001              BEQ      |L1.64|
;;;313    	{
;;;314    		return 1;
00003c  2001              MOVS     r0,#1
                  |L1.62|
;;;315    	}
;;;316    	
;;;317    	return 0;
;;;318    }
00003e  bd1c              POP      {r2-r4,pc}
                  |L1.64|
000040  2000              MOVS     r0,#0                 ;317
000042  e7fc              B        |L1.62|
;;;319    
                          ENDP

                  |L1.68|
000044  a5a5a5a5          DCB      165,165,165,165,165,0
000048  a500    
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||i.nrf24l01_gpio_init||, CODE, READONLY, ALIGN=2

                  nrf24l01_gpio_init PROC
;;;32     //---------------------------------------------------------------------------------------------------------------------------------------------
;;;33     void nrf24l01_gpio_init(void)
000000  b508              PUSH     {r3,lr}
;;;34     {
;;;35         GPIO_InitTypeDef gpio_config_init;
;;;36     
;;;37     	RCC_APB2PeriphClockCmd(RCC_PCLK_NRF_GPIO_CS, ENABLE);		//开启NRF CS GPIO时钟
000002  2101              MOVS     r1,#1
000004  2010              MOVS     r0,#0x10
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;38     	RCC_APB2PeriphClockCmd(RCC_PCLK_NRF_GPIO_CE, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  2004              MOVS     r0,#4
00000e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;39     	RCC_APB2PeriphClockCmd(RCC_PCLK_NRF_GPIO_IRQ, ENABLE);
000012  2101              MOVS     r1,#1
000014  2004              MOVS     r0,#4
000016  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;40     
;;;41     	gpio_config_init.GPIO_Pin 	= NRF_CS_IO;	//NRF_CS_IO IO初始化
00001a  2010              MOVS     r0,#0x10
00001c  f8ad0000          STRH     r0,[sp,#0]
;;;42     	gpio_config_init.GPIO_Mode 	= GPIO_Mode_Out_PP;  //推挽输出
000020  f88d0003          STRB     r0,[sp,#3]
;;;43     	gpio_config_init.GPIO_Speed = GPIO_Speed_50MHz;
000024  2003              MOVS     r0,#3
000026  f88d0002          STRB     r0,[sp,#2]
;;;44     	GPIO_Init(PORT_NRF_CS, &gpio_config_init);
00002a  4669              MOV      r1,sp
00002c  4812              LDR      r0,|L2.120|
00002e  f7fffffe          BL       GPIO_Init
;;;45     
;;;46     	GPIO_SetBits(PORT_NRF_CS, NRF_CS_IO);	//IO初始状态都设置为高电平
000032  2110              MOVS     r1,#0x10
000034  4810              LDR      r0,|L2.120|
000036  f7fffffe          BL       GPIO_SetBits
;;;47     	
;;;48     	gpio_config_init.GPIO_Pin 	= NRF_CE_IO;
00003a  2010              MOVS     r0,#0x10
00003c  f8ad0000          STRH     r0,[sp,#0]
;;;49     	gpio_config_init.GPIO_Mode 	= GPIO_Mode_Out_PP;
000040  f88d0003          STRB     r0,[sp,#3]
;;;50     	gpio_config_init.GPIO_Speed = GPIO_Speed_50MHz;
000044  2003              MOVS     r0,#3
000046  f88d0002          STRB     r0,[sp,#2]
;;;51     	GPIO_Init(PORT_NRF_CE, &gpio_config_init);
00004a  4669              MOV      r1,sp
00004c  480b              LDR      r0,|L2.124|
00004e  f7fffffe          BL       GPIO_Init
;;;52     	
;;;53     	GPIO_SetBits(PORT_NRF_CE, NRF_CE_IO);
000052  2110              MOVS     r1,#0x10
000054  4809              LDR      r0,|L2.124|
000056  f7fffffe          BL       GPIO_SetBits
;;;54     	
;;;55     	gpio_config_init.GPIO_Pin 	= NRF_IRQ_IO;
00005a  2002              MOVS     r0,#2
00005c  f8ad0000          STRH     r0,[sp,#0]
;;;56     	gpio_config_init.GPIO_Mode 	= GPIO_Mode_IPU;//上拉输入
000060  2048              MOVS     r0,#0x48
000062  f88d0003          STRB     r0,[sp,#3]
;;;57     	gpio_config_init.GPIO_Speed = GPIO_Speed_50MHz;
000066  2003              MOVS     r0,#3
000068  f88d0002          STRB     r0,[sp,#2]
;;;58     	GPIO_Init(PORT_NRF_IRQ, &gpio_config_init);
00006c  4669              MOV      r1,sp
00006e  4803              LDR      r0,|L2.124|
000070  f7fffffe          BL       GPIO_Init
;;;59     }
000074  bd08              POP      {r3,pc}
;;;60     
                          ENDP

000076  0000              DCW      0x0000
                  |L2.120|
                          DCD      0x40011000
                  |L2.124|
                          DCD      0x40010800

                          AREA ||i.nrf24l01_init||, CODE, READONLY, ALIGN=2

                  nrf24l01_init PROC
;;;345    //---------------------------------------------------------------------------------------------------------------------------------------------
;;;346    void nrf24l01_init(void)
000000  b510              PUSH     {r4,lr}
;;;347    {
;;;348    	nrf24l01_gpio_init();
000002  f7fffffe          BL       nrf24l01_gpio_init
;;;349    	
;;;350    	NRF_CS_1();
000006  2110              MOVS     r1,#0x10
000008  4803              LDR      r0,|L3.24|
00000a  f7fffffe          BL       GPIO_SetBits
;;;351    	NRF_CE_0();
00000e  2110              MOVS     r1,#0x10
000010  4802              LDR      r0,|L3.28|
000012  f7fffffe          BL       GPIO_ResetBits
;;;352    }
000016  bd10              POP      {r4,pc}
;;;353    
                          ENDP

                  |L3.24|
                          DCD      0x40011000
                  |L3.28|
                          DCD      0x40010800

                          AREA ||i.nrf24l01_power_down_mode||, CODE, READONLY, ALIGN=2

                  nrf24l01_power_down_mode PROC
;;;328    //---------------------------------------------------------------------------------------------------------------------------------------------
;;;329    void nrf24l01_power_down_mode(void)
000000  b510              PUSH     {r4,lr}
;;;330    {
;;;331    	NRF_CS_0();
000002  2110              MOVS     r1,#0x10
000004  4805              LDR      r0,|L4.28|
000006  f7fffffe          BL       GPIO_ResetBits
;;;332    	nrf24l01_write_reg(NRF24L01_CONFIG, 0x00);
00000a  2100              MOVS     r1,#0
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       nrf24l01_write_reg
;;;333    	NRF_CS_1();
000012  2110              MOVS     r1,#0x10
000014  4801              LDR      r0,|L4.28|
000016  f7fffffe          BL       GPIO_SetBits
;;;334    	
;;;335    }
00001a  bd10              POP      {r4,pc}
;;;336    
                          ENDP

                  |L4.28|
                          DCD      0x40011000

                          AREA ||i.nrf24l01_read_buff||, CODE, READONLY, ALIGN=2

                  nrf24l01_read_buff PROC
;;;114    //---------------------------------------------------------------------------------------------------------------------------------------------
;;;115    uint8_t nrf24l01_read_buff(uint8_t reg_no, uint8_t *pbdata, uint16_t read_length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;116    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;117    	uint8_t status = 0;
00000a  f04f0800          MOV      r8,#0
;;;118    	uint16_t i = 0;
00000e  2700              MOVS     r7,#0
;;;119    	
;;;120    	NRF_CS_0();
000010  2110              MOVS     r1,#0x10
000012  480d              LDR      r0,|L5.72|
000014  f7fffffe          BL       GPIO_ResetBits
;;;121    	
;;;122    	status = spi_master_send_recv_byte(1, reg_no);
000018  4629              MOV      r1,r5
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       spi_master_send_recv_byte
000020  4680              MOV      r8,r0
;;;123    	
;;;124    	for (i = 0; i < read_length; i++)
000022  bf00              NOP      
000024  e007              B        |L5.54|
                  |L5.38|
;;;125    	{
;;;126    		*pbdata++ = spi_master_send_recv_byte(1, 0xff);	//发送ff得到spi的时钟
000026  21ff              MOVS     r1,#0xff
000028  2001              MOVS     r0,#1
00002a  f7fffffe          BL       spi_master_send_recv_byte
00002e  f8040b01          STRB     r0,[r4],#1
000032  1c78              ADDS     r0,r7,#1              ;124
000034  b287              UXTH     r7,r0                 ;124
                  |L5.54|
000036  42b7              CMP      r7,r6                 ;124
000038  dbf5              BLT      |L5.38|
;;;127    	}
;;;128    	
;;;129    	NRF_CS_1();
00003a  2110              MOVS     r1,#0x10
00003c  4802              LDR      r0,|L5.72|
00003e  f7fffffe          BL       GPIO_SetBits
;;;130    	
;;;131    	return status;
000042  4640              MOV      r0,r8
;;;132    }
000044  e8bd81f0          POP      {r4-r8,pc}
;;;133    
                          ENDP

                  |L5.72|
                          DCD      0x40011000

                          AREA ||i.nrf24l01_read_reg||, CODE, READONLY, ALIGN=2

                  nrf24l01_read_reg PROC
;;;91     //---------------------------------------------------------------------------------------------------------------------------------------------
;;;92     uint8_t nrf24l01_read_reg(uint8_t reg_no)
000000  b570              PUSH     {r4-r6,lr}
;;;93     {
000002  4604              MOV      r4,r0
;;;94     	uint8_t reg_val = 0;
000004  2500              MOVS     r5,#0
;;;95     	
;;;96     	NRF_CS_0();
000006  2110              MOVS     r1,#0x10
000008  4808              LDR      r0,|L6.44|
00000a  f7fffffe          BL       GPIO_ResetBits
;;;97     	spi_master_send_recv_byte(1, reg_no);
00000e  4621              MOV      r1,r4
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       spi_master_send_recv_byte
;;;98     	reg_val = spi_master_send_recv_byte(1, 0xff);	
000016  21ff              MOVS     r1,#0xff
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       spi_master_send_recv_byte
00001e  4605              MOV      r5,r0
;;;99     	NRF_CS_1();
000020  2110              MOVS     r1,#0x10
000022  4802              LDR      r0,|L6.44|
000024  f7fffffe          BL       GPIO_SetBits
;;;100    	
;;;101    	return reg_val;
000028  4628              MOV      r0,r5
;;;102    }
00002a  bd70              POP      {r4-r6,pc}
;;;103    
                          ENDP

                  |L6.44|
                          DCD      0x40011000

                          AREA ||i.nrf24l01_rx_mode||, CODE, READONLY, ALIGN=2

                  nrf24l01_rx_mode PROC
;;;199    //---------------------------------------------------------------------------------------------------------------------------------------------
;;;200    void nrf24l01_rx_mode(void)
000000  b510              PUSH     {r4,lr}
;;;201    {
;;;202    	NRF_CE_0();
000002  2110              MOVS     r1,#0x10
000004  4812              LDR      r0,|L7.80|
000006  f7fffffe          BL       GPIO_ResetBits
;;;203    	
;;;204    	nrf24l01_write_buff(W_REGISTER + RX_ADDR_P0, (uint8_t *) RX_ADDRESS_X, RX_ADR_WIDTH);	//写RX地址节点
00000a  2205              MOVS     r2,#5
00000c  4911              LDR      r1,|L7.84|
00000e  202a              MOVS     r0,#0x2a
000010  f7fffffe          BL       nrf24l01_write_buff
;;;205    	nrf24l01_write_reg(W_REGISTER + EN_AA, 0x01);	//使能通道0自动应答
000014  2101              MOVS     r1,#1
000016  2021              MOVS     r0,#0x21
000018  f7fffffe          BL       nrf24l01_write_reg
;;;206    	nrf24l01_write_reg(W_REGISTER + EN_RXADDR, 0x01);	//使能通道0接收地址
00001c  2101              MOVS     r1,#1
00001e  2022              MOVS     r0,#0x22
000020  f7fffffe          BL       nrf24l01_write_reg
;;;207    	nrf24l01_write_reg(W_REGISTER + RF_CH, 40);	//设置RF通信频率
000024  2128              MOVS     r1,#0x28
000026  2025              MOVS     r0,#0x25
000028  f7fffffe          BL       nrf24l01_write_reg
;;;208    	nrf24l01_write_reg(W_REGISTER + RX_PW_P0, RX_PLOAD_WIDTH);	//选择通道0有效数据宽度
00002c  2105              MOVS     r1,#5
00002e  2031              MOVS     r0,#0x31
000030  f7fffffe          BL       nrf24l01_write_reg
;;;209    	nrf24l01_write_reg(W_REGISTER + RF_SETUP, 0x0f); //设置TX发射参数:0db增益,2Mbps,低噪声增益开启
000034  210f              MOVS     r1,#0xf
000036  2026              MOVS     r0,#0x26
000038  f7fffffe          BL       nrf24l01_write_reg
;;;210    	nrf24l01_write_reg(W_REGISTER + NRF24L01_CONFIG, 0x0f);	//基本参数:PWR_UP;EN_CRC;16BIT_CRC;接收模式;开启所有中断
00003c  210f              MOVS     r1,#0xf
00003e  2020              MOVS     r0,#0x20
000040  f7fffffe          BL       nrf24l01_write_reg
;;;211    	
;;;212    	NRF_CE_1();//CE为高,进入接收模式
000044  2110              MOVS     r1,#0x10
000046  4802              LDR      r0,|L7.80|
000048  f7fffffe          BL       GPIO_SetBits
;;;213    }
00004c  bd10              POP      {r4,pc}
;;;214    
                          ENDP

00004e  0000              DCW      0x0000
                  |L7.80|
                          DCD      0x40010800
                  |L7.84|
                          DCD      RX_ADDRESS_X

                          AREA ||i.nrf24l01_rx_packet||, CODE, READONLY, ALIGN=2

                  nrf24l01_rx_packet PROC
;;;262    //---------------------------------------------------------------------------------------------------------------------------------------------
;;;263    uint8_t nrf24l01_rx_packet(uint8_t *rx_buf)
000000  b570              PUSH     {r4-r6,lr}
;;;264    {
000002  4604              MOV      r4,r0
;;;265    	uint8_t ret_val = 0;
000004  2500              MOVS     r5,#0
;;;266    
;;;267    	NRF_CE_1();
000006  2110              MOVS     r1,#0x10
000008  4812              LDR      r0,|L8.84|
00000a  f7fffffe          BL       GPIO_SetBits
;;;268    	
;;;269    	while(GET_NRF_IRQ_STATUS);
00000e  bf00              NOP      
                  |L8.16|
000010  2102              MOVS     r1,#2
000012  4810              LDR      r0,|L8.84|
000014  f7fffffe          BL       GPIO_ReadInputDataBit
000018  2800              CMP      r0,#0
00001a  d1f9              BNE      |L8.16|
;;;270    	
;;;271    	NRF_CE_0();
00001c  2110              MOVS     r1,#0x10
00001e  480d              LDR      r0,|L8.84|
000020  f7fffffe          BL       GPIO_ResetBits
;;;272    
;;;273    	ret_val = nrf24l01_read_reg(NRF24L01_STATUS);	//读取状态寄存器的值
000024  2007              MOVS     r0,#7
000026  f7fffffe          BL       nrf24l01_read_reg
00002a  4605              MOV      r5,r0
;;;274    	nrf24l01_write_reg(W_REGISTER+NRF24L01_STATUS, ret_val);	//清除TX_DS or MAX_RT的中断标志
00002c  4629              MOV      r1,r5
00002e  2027              MOVS     r0,#0x27
000030  f7fffffe          BL       nrf24l01_write_reg
;;;275    	
;;;276    	if(ret_val & RX_OK)	//接收到数据
000034  f0050040          AND      r0,r5,#0x40
000038  b150              CBZ      r0,|L8.80|
;;;277    	{
;;;278    		nrf24l01_read_buff(R_RX_PAYLOAD, rx_buf, RX_PLOAD_WIDTH);	//读取数据
00003a  2205              MOVS     r2,#5
00003c  4621              MOV      r1,r4
00003e  2061              MOVS     r0,#0x61
000040  f7fffffe          BL       nrf24l01_read_buff
;;;279    		nrf24l01_write_reg(FLUSH_RX, 0xff);	//清除RX FIFO寄存器
000044  21ff              MOVS     r1,#0xff
000046  20e2              MOVS     r0,#0xe2
000048  f7fffffe          BL       nrf24l01_write_reg
;;;280    		
;;;281    		return RX_SUCCESS;
00004c  2000              MOVS     r0,#0
                  |L8.78|
;;;282    	}
;;;283    	
;;;284    	return RX_FAIL;	//没有接收到数据
;;;285    }
00004e  bd70              POP      {r4-r6,pc}
                  |L8.80|
000050  20ff              MOVS     r0,#0xff              ;284
000052  e7fc              B        |L8.78|
;;;286    
                          ENDP

                  |L8.84|
                          DCD      0x40010800

                          AREA ||i.nrf24l01_tx_mode||, CODE, READONLY, ALIGN=2

                  nrf24l01_tx_mode PROC
;;;172    //---------------------------------------------------------------------------------------------------------------------------------------------
;;;173    void nrf24l01_tx_mode(void)
000000  b510              PUSH     {r4,lr}
;;;174    {
;;;175    	NRF_CE_0();
000002  2110              MOVS     r1,#0x10
000004  4816              LDR      r0,|L9.96|
000006  f7fffffe          BL       GPIO_ResetBits
;;;176    	
;;;177    	nrf24l01_write_buff(W_REGISTER + TX_ADDR, (uint8_t *)TX_ADDRESS_X, TX_ADR_WIDTH);	//写TX节点地址
00000a  2205              MOVS     r2,#5
00000c  4915              LDR      r1,|L9.100|
00000e  2030              MOVS     r0,#0x30
000010  f7fffffe          BL       nrf24l01_write_buff
;;;178    	nrf24l01_write_buff(W_REGISTER + RX_ADDR_P0, (uint8_t *) RX_ADDRESS_X, RX_ADR_WIDTH);	//写RX节点地址,为了自动使能ACK
000014  2205              MOVS     r2,#5
000016  4914              LDR      r1,|L9.104|
000018  202a              MOVS     r0,#0x2a
00001a  f7fffffe          BL       nrf24l01_write_buff
;;;179    	nrf24l01_write_reg(W_REGISTER + EN_AA, 0x01);	//使能通道0自动应答
00001e  2101              MOVS     r1,#1
000020  2021              MOVS     r0,#0x21
000022  f7fffffe          BL       nrf24l01_write_reg
;;;180    	nrf24l01_write_reg(W_REGISTER + EN_RXADDR, 0x01);	//使能通道0接收地址
000026  2101              MOVS     r1,#1
000028  2022              MOVS     r0,#0x22
00002a  f7fffffe          BL       nrf24l01_write_reg
;;;181    	nrf24l01_write_reg(W_REGISTER + SETUP_PETR, 0x1a);	//设置自动重发间隔时间:500us+86us,最大重大次数:10次
00002e  211a              MOVS     r1,#0x1a
000030  2024              MOVS     r0,#0x24
000032  f7fffffe          BL       nrf24l01_write_reg
;;;182    	nrf24l01_write_reg(W_REGISTER + RF_CH, 40);	//设置通道为40
000036  2128              MOVS     r1,#0x28
000038  2025              MOVS     r0,#0x25
00003a  f7fffffe          BL       nrf24l01_write_reg
;;;183    	nrf24l01_write_reg(W_REGISTER + RF_SETUP, 0x0f);	//设置发射参数:0dB增益;2Mnps;低噪声增益开启
00003e  210f              MOVS     r1,#0xf
000040  2026              MOVS     r0,#0x26
000042  f7fffffe          BL       nrf24l01_write_reg
;;;184    	nrf24l01_write_reg(W_REGISTER + NRF24L01_CONFIG, 0x0e);	//基本参数:PWR_UP;EN_CRC;16BIT_CRC;发送模式;开启所有中断
000046  210e              MOVS     r1,#0xe
000048  2020              MOVS     r0,#0x20
00004a  f7fffffe          BL       nrf24l01_write_reg
;;;185    	
;;;186    	NRF_CE_1();
00004e  2110              MOVS     r1,#0x10
000050  4803              LDR      r0,|L9.96|
000052  f7fffffe          BL       GPIO_SetBits
;;;187    	
;;;188    	delay_us(12);
000056  200c              MOVS     r0,#0xc
000058  f7fffffe          BL       delay_us
;;;189    }
00005c  bd10              POP      {r4,pc}
;;;190    
                          ENDP

00005e  0000              DCW      0x0000
                  |L9.96|
                          DCD      0x40010800
                  |L9.100|
                          DCD      TX_ADDRESS_X
                  |L9.104|
                          DCD      RX_ADDRESS_X

                          AREA ||i.nrf24l01_tx_packet||, CODE, READONLY, ALIGN=2

                  nrf24l01_tx_packet PROC
;;;223    //---------------------------------------------------------------------------------------------------------------------------------------------
;;;224    uint8_t nrf24l01_tx_packet(uint8_t *tx_buff)
000000  b570              PUSH     {r4-r6,lr}
;;;225    {
000002  4605              MOV      r5,r0
;;;226    	uint8_t ret_val = 0;
000004  2400              MOVS     r4,#0
;;;227    
;;;228    	NRF_CE_0();
000006  2110              MOVS     r1,#0x10
000008  4815              LDR      r0,|L10.96|
00000a  f7fffffe          BL       GPIO_ResetBits
;;;229    	
;;;230    	nrf24l01_write_buff(W_TX_PAYLOAD, tx_buff, TX_PLOAD_WIDTH);	//写数据到txbuf,32字节
00000e  2205              MOVS     r2,#5
000010  4629              MOV      r1,r5
000012  20a0              MOVS     r0,#0xa0
000014  f7fffffe          BL       nrf24l01_write_buff
;;;231    	
;;;232    	NRF_CE_1();	//启动发送
000018  2110              MOVS     r1,#0x10
00001a  4811              LDR      r0,|L10.96|
00001c  f7fffffe          BL       GPIO_SetBits
;;;233    	
;;;234    	while (GET_NRF_IRQ_STATUS);//等待发送完成
000020  bf00              NOP      
                  |L10.34|
000022  2102              MOVS     r1,#2
000024  480e              LDR      r0,|L10.96|
000026  f7fffffe          BL       GPIO_ReadInputDataBit
00002a  2800              CMP      r0,#0
00002c  d1f9              BNE      |L10.34|
;;;235    	
;;;236    	ret_val = nrf24l01_read_reg(NRF24L01_STATUS);	//读取状态寄存器的值
00002e  2007              MOVS     r0,#7
000030  f7fffffe          BL       nrf24l01_read_reg
000034  4604              MOV      r4,r0
;;;237    	nrf24l01_write_reg(W_REGISTER + NRF24L01_STATUS, ret_val);	//清除TX_DS or MAX_RT的中断标志
000036  4621              MOV      r1,r4
000038  2027              MOVS     r0,#0x27
00003a  f7fffffe          BL       nrf24l01_write_reg
;;;238    	
;;;239    	if (ret_val & MAX_TX)	//达到最大重发次数
00003e  f0040010          AND      r0,r4,#0x10
000042  b128              CBZ      r0,|L10.80|
;;;240    	{
;;;241    		nrf24l01_write_reg(FLUSH_TX, 0xff);	//清除TX FIFO寄存器
000044  21ff              MOVS     r1,#0xff
000046  20e1              MOVS     r0,#0xe1
000048  f7fffffe          BL       nrf24l01_write_reg
;;;242    		
;;;243    		return MAX_TX;
00004c  2010              MOVS     r0,#0x10
                  |L10.78|
;;;244    	}
;;;245    	
;;;246    	if(ret_val & TX_OK)	//发送完成
;;;247    	{
;;;248    		return TX_OK;
;;;249    	}
;;;250    	
;;;251    	return TX_FAIL;//发送失败
;;;252    }
00004e  bd70              POP      {r4-r6,pc}
                  |L10.80|
000050  f0040020          AND      r0,r4,#0x20           ;246
000054  b108              CBZ      r0,|L10.90|
000056  2020              MOVS     r0,#0x20              ;248
000058  e7f9              B        |L10.78|
                  |L10.90|
00005a  20ff              MOVS     r0,#0xff              ;251
00005c  e7f7              B        |L10.78|
;;;253    
                          ENDP

00005e  0000              DCW      0x0000
                  |L10.96|
                          DCD      0x40010800

                          AREA ||i.nrf24l01_write_buff||, CODE, READONLY, ALIGN=2

                  nrf24l01_write_buff PROC
;;;144    //---------------------------------------------------------------------------------------------------------------------------------------------
;;;145    uint8_t nrf24l01_write_buff(uint8_t reg_no, uint8_t *pbdata, uint16_t write_length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;146    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;147    	uint8_t status = 0;
00000a  f04f0800          MOV      r8,#0
;;;148    	uint16_t i = 0;
00000e  2400              MOVS     r4,#0
;;;149    	
;;;150    	NRF_CS_0();
000010  2110              MOVS     r1,#0x10
000012  480c              LDR      r0,|L11.68|
000014  f7fffffe          BL       GPIO_ResetBits
;;;151    	
;;;152    	status = spi_master_send_recv_byte(1, reg_no);
000018  4629              MOV      r1,r5
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       spi_master_send_recv_byte
000020  4680              MOV      r8,r0
;;;153    	
;;;154    	for (i = 0; i < write_length; i++)
000022  bf00              NOP      
000024  e005              B        |L11.50|
                  |L11.38|
;;;155    	{
;;;156    		spi_master_send_recv_byte(1, pbdata[i]);	//连续写入数据
000026  5d31              LDRB     r1,[r6,r4]
000028  2001              MOVS     r0,#1
00002a  f7fffffe          BL       spi_master_send_recv_byte
00002e  1c60              ADDS     r0,r4,#1              ;154
000030  b284              UXTH     r4,r0                 ;154
                  |L11.50|
000032  42bc              CMP      r4,r7                 ;154
000034  dbf7              BLT      |L11.38|
;;;157    	}
;;;158    	
;;;159    	NRF_CS_1();
000036  2110              MOVS     r1,#0x10
000038  4802              LDR      r0,|L11.68|
00003a  f7fffffe          BL       GPIO_SetBits
;;;160    	
;;;161    	return status;
00003e  4640              MOV      r0,r8
;;;162    }
000040  e8bd81f0          POP      {r4-r8,pc}
;;;163    
                          ENDP

                  |L11.68|
                          DCD      0x40011000

                          AREA ||i.nrf24l01_write_reg||, CODE, READONLY, ALIGN=2

                  nrf24l01_write_reg PROC
;;;70     //---------------------------------------------------------------------------------------------------------------------------------------------
;;;71     uint8_t nrf24l01_write_reg(uint8_t reg_no, uint8_t reg_val)
000000  b570              PUSH     {r4-r6,lr}
;;;72     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;73     	uint8_t status = 0;
000006  2600              MOVS     r6,#0
;;;74     	
;;;75     	NRF_CS_0();
000008  2110              MOVS     r1,#0x10
00000a  4809              LDR      r0,|L12.48|
00000c  f7fffffe          BL       GPIO_ResetBits
;;;76     	status = spi_master_send_recv_byte(1, reg_no);
000010  4621              MOV      r1,r4
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       spi_master_send_recv_byte
000018  4606              MOV      r6,r0
;;;77     	spi_master_send_recv_byte(1, reg_val);
00001a  4629              MOV      r1,r5
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       spi_master_send_recv_byte
;;;78     	NRF_CS_1();
000022  2110              MOVS     r1,#0x10
000024  4802              LDR      r0,|L12.48|
000026  f7fffffe          BL       GPIO_SetBits
;;;79     	
;;;80     	return status;
00002a  4630              MOV      r0,r6
;;;81     }
00002c  bd70              POP      {r4-r6,pc}
;;;82     
                          ENDP

00002e  0000              DCW      0x0000
                  |L12.48|
                          DCD      0x40011000

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  TX_ADDRESS_X
000000  34431010          DCB      0x34,0x43,0x10,0x10
000004  01                DCB      0x01
                  RX_ADDRESS_X
000005  344310            DCB      0x34,0x43,0x10
000008  1001              DCB      0x10,0x01
