; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\app_htu21d.o --asm_dir=.\ --list_dir=.\ --depend=.\app_htu21d.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\App\inc -I..\Driver\inc -I..\Libraries\CMSIS\Core\inc -I..\Libraries\CMSIS\Device\inc -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\HalIterface\inc -I..\User\inc -I..\Driver\src -ID:\KEIL_ARM_PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\keil_arm\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=533 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\app_htu21d.crf ..\App\src\app_htu21d.c]
                          THUMB

                          AREA ||i.Htu_Display||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_f
                          REQUIRE _printf_fp_dec
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  Htu_Display PROC
;;;225    //--------------------------------------------------------------------------------------------------------
;;;226     void Htu_Display(void)
000000  b570              PUSH     {r4-r6,lr}
;;;227    {
000002  b086              SUB      sp,sp,#0x18
;;;228    	u16 usTemp = 0;
000004  2400              MOVS     r4,#0
;;;229    	volatile double f_RetVal = 0.0;
000006  2100              MOVS     r1,#0
000008  9104              STR      r1,[sp,#0x10]
00000a  9105              STR      r1,[sp,#0x14]
;;;230    	u8 ucTest[10] = {0};
00000c  2000              MOVS     r0,#0
00000e  9001              STR      r0,[sp,#4]
000010  9002              STR      r0,[sp,#8]
000012  9003              STR      r0,[sp,#0xc]
;;;231    	
;;;232    	f_RetVal = Htu_Measure(HTU_TEMP);//得到温度值
000014  20f3              MOVS     r0,#0xf3
000016  f7fffffe          BL       Htu_Measure
00001a  4605              MOV      r5,r0
00001c  f7fffffe          BL       __aeabi_f2d
000020  e9cd0104          STRD     r0,r1,[sp,#0x10]
;;;233    	printf("The htu measure temp is :%4.2fC \r\n", f_RetVal);
000024  a028              ADR      r0,|L1.200|
000026  e9dd2304          LDRD     r2,r3,[sp,#0x10]
00002a  f7fffffe          BL       __2printf
;;;234    	
;;;235    	sprintf((char*)ucTest,"%4.2f", f_RetVal);		//LCD显示方式1：sprintf函数将结果打印到test数组里,转换成字符串
00002e  a12f              ADR      r1,|L1.236|
000030  a801              ADD      r0,sp,#4
000032  e9dd2304          LDRD     r2,r3,[sp,#0x10]
000036  f7fffffe          BL       __2sprintf
;;;236    	printf("test is %sC \r\n", ucTest);
00003a  a901              ADD      r1,sp,#4
00003c  a02d              ADR      r0,|L1.244|
00003e  f7fffffe          BL       __2printf
;;;237    	printf("\r\n");
000042  a029              ADR      r0,|L1.232|
000044  f7fffffe          BL       __2printf
;;;238    
;;;239    	
;;;240    	usTemp = f_RetVal;			//LCD显示方式2:将得到的数值拆分成整数和小数直接显示在液晶
000048  e9dd0104          LDRD     r0,r1,[sp,#0x10]
00004c  f7fffffe          BL       __aeabi_d2uiz
000050  b284              UXTH     r4,r0
;;;241    	f_RetVal -= usTemp;
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       __aeabi_ui2d
000058  4605              MOV      r5,r0
00005a  e9dd2304          LDRD     r2,r3,[sp,#0x10]
00005e  f7fffffe          BL       __aeabi_drsub
000062  e9cd0104          STRD     r0,r1,[sp,#0x10]
;;;242    	f_RetVal *= 100;		//保留两位小数
000066  2200              MOVS     r2,#0
000068  4b26              LDR      r3,|L1.260|
00006a  e9dd0104          LDRD     r0,r1,[sp,#0x10]
00006e  f7fffffe          BL       __aeabi_dmul
000072  e9cd0104          STRD     r0,r1,[sp,#0x10]
;;;243    
;;;244    		
;;;245    	f_RetVal= Htu_Measure(HTU_HUMI);		//得到湿度值
000076  20f5              MOVS     r0,#0xf5
000078  f7fffffe          BL       Htu_Measure
00007c  4605              MOV      r5,r0
00007e  f7fffffe          BL       __aeabi_f2d
000082  e9cd0104          STRD     r0,r1,[sp,#0x10]
;;;246    	printf("The htu measure humi is :%4.2fRH \r\n", f_RetVal);
000086  a020              ADR      r0,|L1.264|
000088  e9dd2304          LDRD     r2,r3,[sp,#0x10]
00008c  f7fffffe          BL       __2printf
;;;247    	usTemp = f_RetVal;
000090  e9dd0104          LDRD     r0,r1,[sp,#0x10]
000094  f7fffffe          BL       __aeabi_d2uiz
000098  b284              UXTH     r4,r0
;;;248    	f_RetVal -= usTemp;
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       __aeabi_ui2d
0000a0  4605              MOV      r5,r0
0000a2  e9dd2304          LDRD     r2,r3,[sp,#0x10]
0000a6  f7fffffe          BL       __aeabi_drsub
0000aa  e9cd0104          STRD     r0,r1,[sp,#0x10]
;;;249    	f_RetVal *= 100;
0000ae  2200              MOVS     r2,#0
0000b0  4b14              LDR      r3,|L1.260|
0000b2  e9dd0104          LDRD     r0,r1,[sp,#0x10]
0000b6  f7fffffe          BL       __aeabi_dmul
0000ba  e9cd0104          STRD     r0,r1,[sp,#0x10]
;;;250    	printf("\r\n");
0000be  a00a              ADR      r0,|L1.232|
0000c0  f7fffffe          BL       __2printf
;;;251    	
;;;252    }
0000c4  b006              ADD      sp,sp,#0x18
0000c6  bd70              POP      {r4-r6,pc}
;;;253    
                          ENDP

                  |L1.200|
0000c8  54686520          DCB      "The htu measure temp is :%4.2fC "
0000cc  68747520
0000d0  6d656173
0000d4  75726520
0000d8  74656d70
0000dc  20697320
0000e0  3a25342e
0000e4  32664320
                  |L1.232|
0000e8  0d0a00            DCB      "\r\n",0
0000eb  00                DCB      0
                  |L1.236|
0000ec  25342e32          DCB      "%4.2f",0
0000f0  6600    
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L1.244|
0000f4  74657374          DCB      "test is %sC \r\n",0
0000f8  20697320
0000fc  25734320
000100  0d0a00  
000103  00                DCB      0
                  |L1.260|
                          DCD      0x40590000
                  |L1.264|
000108  54686520          DCB      "The htu measure humi is :%4.2fRH \r\n",0
00010c  68747520
000110  6d656173
000114  75726520
000118  68756d69
00011c  20697320
000120  3a25342e
000124  32665248
000128  200d0a00

                          AREA ||i.Htu_Init||, CODE, READONLY, ALIGN=1

                  Htu_Init PROC
;;;22     //---------------------------------------------------------------------------------------------------------------------------------------------
;;;23     void Htu_Init(void)
000000  b510              PUSH     {r4,lr}
;;;24     {
;;;25     	  
;;;26     	I2c_Init();
000002  f7fffffe          BL       I2c_Init
;;;27     	I2c_Start();
000006  f7fffffe          BL       I2c_Start
;;;28     	I2c_SendOneByte(HTU_ADDR_WR);	//写I2C器件地址
00000a  2080              MOVS     r0,#0x80
00000c  f7fffffe          BL       I2c_SendOneByte
;;;29     	I2c_WaitAck(200);
000010  20c8              MOVS     r0,#0xc8
000012  f7fffffe          BL       I2c_WaitAck
;;;30     	I2c_SendOneByte(HTU_SOFTWARE_RESET);		//软复位
000016  20fe              MOVS     r0,#0xfe
000018  f7fffffe          BL       I2c_SendOneByte
;;;31     	I2c_WaitAck(200);
00001c  20c8              MOVS     r0,#0xc8
00001e  f7fffffe          BL       I2c_WaitAck
;;;32     	I2c_Stop();
000022  f7fffffe          BL       I2c_Stop
;;;33     	delay_ms(15);		//软复位时间最多需要15ms
000026  200f              MOVS     r0,#0xf
000028  f7fffffe          BL       delay_ms
;;;34     }
00002c  bd10              POP      {r4,pc}
;;;35     
                          ENDP


                          AREA ||i.Htu_Measure||, CODE, READONLY, ALIGN=2

                  Htu_Measure PROC
;;;45     #if 1
;;;46     float Htu_Measure(uint8_t _ucOrder)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;47     {
000004  b088              SUB      sp,sp,#0x20
000006  4604              MOV      r4,r0
;;;48     	 uint8_t ucMsb = 0;
000008  f04f0900          MOV      r9,#0
;;;49     	 uint8_t ucLsb = 0;
00000c  46ca              MOV      r10,r9
;;;50     	 volatile float fTemp = 0.0;
00000e  2000              MOVS     r0,#0
000010  9006              STR      r0,[sp,#0x18]
;;;51     	 volatile float fHumi = 0.0;
000012  9005              STR      r0,[sp,#0x14]
;;;52     	 volatile float fRetVal = 0.0;
000014  9004              STR      r0,[sp,#0x10]
;;;53     	 
;;;54     	 I2c_Start();
000016  f7fffffe          BL       I2c_Start
;;;55     	 
;;;56     	 I2c_SendOneByte(HTU_ADDR_WR);		//地址+写命令
00001a  2080              MOVS     r0,#0x80
00001c  f7fffffe          BL       I2c_SendOneByte
;;;57     	 if(I2c_WaitAck(200)==I2C_NACK)
000020  20c8              MOVS     r0,#0xc8
000022  f7fffffe          BL       I2c_WaitAck
000026  2801              CMP      r0,#1
000028  d103              BNE      |L3.50|
;;;58     	{
;;;59     		 return false;
00002a  2000              MOVS     r0,#0
                  |L3.44|
;;;60     	}
;;;61     	 
;;;62     	I2c_SendOneByte(_ucOrder);		//触发测量命令
;;;63     	if(I2c_WaitAck(200)==I2C_NACK)
;;;64     	{
;;;65     		 return false;
;;;66     	}
;;;67     	
;;;68     	Sys_delay_ms(50);	//14位测量时间范围(44-58ms)
;;;69     	 
;;;70     	do{
;;;71     	//	delay_ms(5);
;;;72     		I2c_Start();	//重启总线
;;;73     		I2c_SendOneByte(HTU_ADDR_RD);		//地址+读命令
;;;74     	}while(I2c_WaitAck(1)==I2C_NACK);
;;;75     
;;;76     	ucMsb = I2c_RecvOneByte(I2C_ACK);	//主机给出ACK
;;;77     	ucLsb = I2c_RecvOneByte(I2C_NACK);	//读取的最后一字节发送NACK
;;;78     
;;;79     	I2c_Stop();
;;;80     
;;;81     	ucLsb &= 0xFC;		//设置分辨率,最低两位为0,温度:14位;湿度:12位 	
;;;82     	fRetVal = ucMsb * 256 + ucLsb;/*MSB=(MSB<<=8)+LSB;即将MSB移位到高8位*/
;;;83     
;;;84     	if(_ucOrder == HTU_TEMP)
;;;85     	{
;;;86     		fTemp = (175.72) * fRetVal / 65536 - 46.85;//温度:T= -46.85 + 175.72 * ST/2^16
;;;87     
;;;88     		return fTemp;
;;;89     	}
;;;90     	else if(_ucOrder == HTU_HUMI)
;;;91     	{
;;;92     		fHumi = (fRetVal * 125) / 65536 - 6;//湿度: RH%= -6 + 125 * SRH/2^16
;;;93     
;;;94     		return fHumi;
;;;95     	}
;;;96     	else
;;;97     	{
;;;98     		return false;
;;;99     	}
;;;100    } 
00002c  b008              ADD      sp,sp,#0x20
00002e  e8bd87f0          POP      {r4-r10,pc}
                  |L3.50|
000032  4620              MOV      r0,r4                 ;62
000034  f7fffffe          BL       I2c_SendOneByte
000038  20c8              MOVS     r0,#0xc8              ;63
00003a  f7fffffe          BL       I2c_WaitAck
00003e  2801              CMP      r0,#1                 ;63
000040  d101              BNE      |L3.70|
000042  2000              MOVS     r0,#0                 ;65
000044  e7f2              B        |L3.44|
                  |L3.70|
000046  2032              MOVS     r0,#0x32              ;68
000048  f7fffffe          BL       Sys_delay_ms
00004c  bf00              NOP                            ;70
                  |L3.78|
00004e  f7fffffe          BL       I2c_Start
000052  2081              MOVS     r0,#0x81              ;73
000054  f7fffffe          BL       I2c_SendOneByte
000058  2001              MOVS     r0,#1                 ;74
00005a  f7fffffe          BL       I2c_WaitAck
00005e  2801              CMP      r0,#1                 ;74
000060  d0f5              BEQ      |L3.78|
000062  2000              MOVS     r0,#0                 ;76
000064  f7fffffe          BL       I2c_RecvOneByte
000068  4681              MOV      r9,r0                 ;76
00006a  2001              MOVS     r0,#1                 ;77
00006c  f7fffffe          BL       I2c_RecvOneByte
000070  4682              MOV      r10,r0                ;77
000072  f7fffffe          BL       I2c_Stop
000076  f00a0afc          AND      r10,r10,#0xfc         ;81
00007a  eb0a2009          ADD      r0,r10,r9,LSL #8      ;82
00007e  f7fffffe          BL       __aeabi_i2f
000082  9004              STR      r0,[sp,#0x10]         ;82
000084  2cf3              CMP      r4,#0xf3              ;84
000086  d119              BNE      |L3.188|
000088  9804              LDR      r0,[sp,#0x10]         ;86
00008a  f7fffffe          BL       __aeabi_f2d
00008e  4a15              LDR      r2,|L3.228|
000090  4b15              LDR      r3,|L3.232|
000092  e9cd0100          STRD     r0,r1,[sp,#0]         ;86
000096  f7fffffe          BL       __aeabi_dmul
00009a  4607              MOV      r7,r0                 ;86
00009c  2200              MOVS     r2,#0                 ;86
00009e  4b13              LDR      r3,|L3.236|
0000a0  f7fffffe          BL       __aeabi_ddiv
0000a4  4605              MOV      r5,r0                 ;86
0000a6  4a12              LDR      r2,|L3.240|
0000a8  4b12              LDR      r3,|L3.244|
0000aa  f7fffffe          BL       __aeabi_dsub
0000ae  e9cd0102          STRD     r0,r1,[sp,#8]         ;86
0000b2  f7fffffe          BL       __aeabi_d2f
0000b6  9006              STR      r0,[sp,#0x18]         ;86
0000b8  9806              LDR      r0,[sp,#0x18]         ;88
0000ba  e7b7              B        |L3.44|
                  |L3.188|
0000bc  2cf5              CMP      r4,#0xf5              ;90
0000be  d10f              BNE      |L3.224|
0000c0  490d              LDR      r1,|L3.248|
0000c2  9804              LDR      r0,[sp,#0x10]         ;92
0000c4  f7fffffe          BL       __aeabi_fmul
0000c8  4606              MOV      r6,r0                 ;92
0000ca  f04f418f          MOV      r1,#0x47800000        ;92
0000ce  f7fffffe          BL       __aeabi_fdiv
0000d2  4605              MOV      r5,r0                 ;92
0000d4  4909              LDR      r1,|L3.252|
0000d6  f7fffffe          BL       __aeabi_fsub
0000da  9005              STR      r0,[sp,#0x14]         ;92
0000dc  9805              LDR      r0,[sp,#0x14]         ;94
0000de  e7a5              B        |L3.44|
                  |L3.224|
0000e0  2000              MOVS     r0,#0                 ;98
0000e2  e7a3              B        |L3.44|
;;;101    
                          ENDP

                  |L3.228|
                          DCD      0x3d70a3d7
                  |L3.232|
                          DCD      0x4065f70a
                  |L3.236|
                          DCD      0x40f00000
                  |L3.240|
                          DCD      0xcccccccd
                  |L3.244|
                          DCD      0x40476ccc
                  |L3.248|
                          DCD      0x42fa0000
                  |L3.252|
                          DCD      0x40c00000

                          AREA ||i.htu_read_some_bytes||, CODE, READONLY, ALIGN=1

                  htu_read_some_bytes PROC
;;;195    //-------------------------------------------------------------------------------------------------------------------------
;;;196    bool htu_read_some_bytes(uint8_t *pbdata, uint16_t read_length)
000000  b570              PUSH     {r4-r6,lr}
;;;197    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;198    	I2c_Start();
000006  f7fffffe          BL       I2c_Start
;;;199    
;;;200    	I2c_SendOneByte(HTU_ADDR_RD);
00000a  2081              MOVS     r0,#0x81
00000c  f7fffffe          BL       I2c_SendOneByte
;;;201    	if (I2C_NACK == I2c_WaitAck(200))
000010  20c8              MOVS     r0,#0xc8
000012  f7fffffe          BL       I2c_WaitAck
000016  2801              CMP      r0,#1
000018  d101              BNE      |L4.30|
;;;202    	{
;;;203    		return false;
00001a  2000              MOVS     r0,#0
                  |L4.28|
;;;204    	}
;;;205    
;;;206    	for (uint16_t i = 0; i < read_length - 1; i++)
;;;207    	{
;;;208    		*pbdata++ = I2c_RecvOneByte(I2C_ACK);
;;;209    	}
;;;210    	*pbdata++ = I2c_RecvOneByte(I2C_NACK);	//接收最后一个字节发送NACK,告诉从机读操作已经完成
;;;211    
;;;212    	I2c_Stop();
;;;213    
;;;214    	return true;
;;;215    }
00001c  bd70              POP      {r4-r6,pc}
                  |L4.30|
00001e  2600              MOVS     r6,#0                 ;206
000020  e006              B        |L4.48|
                  |L4.34|
000022  2000              MOVS     r0,#0                 ;208
000024  f7fffffe          BL       I2c_RecvOneByte
000028  f8040b01          STRB     r0,[r4],#1            ;208
00002c  1c70              ADDS     r0,r6,#1              ;206
00002e  b286              UXTH     r6,r0                 ;206
                  |L4.48|
000030  1e68              SUBS     r0,r5,#1              ;206
000032  42b0              CMP      r0,r6                 ;206
000034  dcf5              BGT      |L4.34|
000036  2001              MOVS     r0,#1                 ;210
000038  f7fffffe          BL       I2c_RecvOneByte
00003c  f8040b01          STRB     r0,[r4],#1            ;210
000040  f7fffffe          BL       I2c_Stop
000044  2001              MOVS     r0,#1                 ;214
000046  e7e9              B        |L4.28|
;;;216    
                          ENDP


                          AREA ||i.htu_write_some_bytes||, CODE, READONLY, ALIGN=1

                  htu_write_some_bytes PROC
;;;149    //-------------------------------------------------------------------------------------------------------------------------
;;;150    bool htu_write_some_bytes(uint8_t *pbdata, uint16_t write_length)
000000  b570              PUSH     {r4-r6,lr}
;;;151    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;152    	I2c_Start();
000006  f7fffffe          BL       I2c_Start
;;;153    
;;;154    	I2c_SendOneByte(HTU_ADDR_WR);
00000a  2080              MOVS     r0,#0x80
00000c  f7fffffe          BL       I2c_SendOneByte
;;;155    	if (I2C_NACK == I2c_WaitAck(200))
000010  20c8              MOVS     r0,#0xc8
000012  f7fffffe          BL       I2c_WaitAck
000016  2801              CMP      r0,#1
000018  d101              BNE      |L5.30|
;;;156    	{
;;;157    		return false;
00001a  2000              MOVS     r0,#0
                  |L5.28|
;;;158    	}
;;;159    	
;;;160    	//for循环发送多个字节数据
;;;161    	for (uint16_t i = 0; i < write_length; i++)
;;;162    	{
;;;163    		I2c_SendOneByte(pbdata[i]);
;;;164    		if (I2C_NACK == I2c_WaitAck(200))
;;;165    		{
;;;166    			return false;
;;;167    		}
;;;168    	}
;;;169    
;;;170    	//while循环发送多个字节数据
;;;171    //	while (write_length--)
;;;172    //	{
;;;173    //		I2c_SendOneByte(*pbdata++);
;;;174    //		if (I2C_NACK == I2c_WaitAck(200))
;;;175    //		{
;;;176    //			return false;
;;;177    //		}
;;;178    //	}
;;;179    
;;;180    //	I2c_Stop();
;;;181    
;;;182    	return true;
;;;183    	
;;;184    }
00001c  bd70              POP      {r4-r6,pc}
                  |L5.30|
00001e  2400              MOVS     r4,#0                 ;161
000020  e00b              B        |L5.58|
                  |L5.34|
000022  5d28              LDRB     r0,[r5,r4]            ;163
000024  f7fffffe          BL       I2c_SendOneByte
000028  20c8              MOVS     r0,#0xc8              ;164
00002a  f7fffffe          BL       I2c_WaitAck
00002e  2801              CMP      r0,#1                 ;164
000030  d101              BNE      |L5.54|
000032  2000              MOVS     r0,#0                 ;166
000034  e7f2              B        |L5.28|
                  |L5.54|
000036  1c60              ADDS     r0,r4,#1              ;161
000038  b284              UXTH     r4,r0                 ;161
                  |L5.58|
00003a  42b4              CMP      r4,r6                 ;161
00003c  dbf1              BLT      |L5.34|
00003e  2001              MOVS     r0,#1                 ;182
000040  e7ec              B        |L5.28|
;;;185    
                          ENDP

