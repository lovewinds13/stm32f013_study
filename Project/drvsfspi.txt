; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\drvsfspi.o --asm_dir=.\ --list_dir=.\ --depend=.\drvsfspi.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\App\inc -I..\Driver\inc -I..\Libraries\CMSIS\Core\inc -I..\Libraries\CMSIS\Device\inc -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\HalIterface\inc -I..\User\inc -I..\Driver\src -ID:\KEIL_ARM_PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\keil_arm\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=533 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\drvsfspi.crf ..\Driver\src\drvsfspi.c]
                          THUMB

                          AREA ||i.Spi_GpioInit||, CODE, READONLY, ALIGN=2

                  Spi_GpioInit PROC
;;;43     //--------------------------------------------------------------------------------------------------------
;;;44     void Spi_GpioInit(void)
000000  b508              PUSH     {r3,lr}
;;;45     {
;;;46     	GPIO_InitTypeDef gpio_init;
;;;47     	
;;;48     	RCC_APB2PeriphClockCmd(RCC_PCLK_SPI1_IO, ENABLE);	//GPIOA时钟使能
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;49     	RCC_APB2PeriphClockCmd(RCC_PCLK_SPI1_HD, DISABLE);	//SPI1时钟不使能
00000a  2100              MOVS     r1,#0
00000c  f44f5080          MOV      r0,#0x1000
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;50     	
;;;51     	gpio_init.GPIO_Pin = FLASH_CS | SPI_CLK | SPI_MOSI;	//CS,CLK,MOSI IO 端口设置
000014  20a4              MOVS     r0,#0xa4
000016  f8ad0000          STRH     r0,[sp,#0]
;;;52     	gpio_init.GPIO_Speed = GPIO_Speed_2MHz;
00001a  2002              MOVS     r0,#2
00001c  f88d0002          STRB     r0,[sp,#2]
;;;53     	gpio_init.GPIO_Mode = GPIO_Mode_Out_PP;
000020  2010              MOVS     r0,#0x10
000022  f88d0003          STRB     r0,[sp,#3]
;;;54     	GPIO_Init(PORT_SPI1_IO, &gpio_init);
000026  4669              MOV      r1,sp
000028  480a              LDR      r0,|L1.84|
00002a  f7fffffe          BL       GPIO_Init
;;;55     	
;;;56     	gpio_init.GPIO_Pin = SPI_MISO;	//MISO IO 端口设置
00002e  2040              MOVS     r0,#0x40
000030  f8ad0000          STRH     r0,[sp,#0]
;;;57     	gpio_init.GPIO_Speed = GPIO_Speed_2MHz;
000034  2002              MOVS     r0,#2
000036  f88d0002          STRB     r0,[sp,#2]
;;;58     	gpio_init.GPIO_Mode = GPIO_Mode_IN_FLOATING;	//MISO 设置为输入
00003a  2004              MOVS     r0,#4
00003c  f88d0003          STRB     r0,[sp,#3]
;;;59     	GPIO_Init(PORT_SPI1_IO, &gpio_init);
000040  4669              MOV      r1,sp
000042  4804              LDR      r0,|L1.84|
000044  f7fffffe          BL       GPIO_Init
;;;60     	
;;;61     #if _CPOL==0
;;;62     	SPI_CLK_LOW;
000048  2120              MOVS     r1,#0x20
00004a  4802              LDR      r0,|L1.84|
00004c  f7fffffe          BL       GPIO_ResetBits
;;;63     #else
;;;64     	SPI_CLK_HIGH;
;;;65     #endif
;;;66     }
000050  bd08              POP      {r3,pc}
;;;67     
                          ENDP

000052  0000              DCW      0x0000
                  |L1.84|
                          DCD      0x40010800

                          AREA ||i.Spi_ReadByte||, CODE, READONLY, ALIGN=2

                  Spi_ReadByte PROC
;;;110    //--------------------------------------------------------------------------------------------------------
;;;111    uint8_t Spi_ReadByte(void)
000000  b570              PUSH     {r4-r6,lr}
;;;112    {
;;;113    	uint8_t ucDataLen = 0;
000002  2500              MOVS     r5,#0
;;;114    	uint8_t ucTmpVal = 0;
000004  2400              MOVS     r4,#0
;;;115    
;;;116    	SPI_CLK_HIGH;
000006  2120              MOVS     r1,#0x20
000008  480f              LDR      r0,|L2.72|
00000a  f7fffffe          BL       GPIO_SetBits
;;;117    	for(ucDataLen = 0; ucDataLen < 8; ucDataLen++)	
00000e  bf00              NOP      
000010  e015              B        |L2.62|
                  |L2.18|
;;;118    	{
;;;119    		SPI_CLK_LOW;	//上升沿后读取数据
000012  2120              MOVS     r1,#0x20
000014  480c              LDR      r0,|L2.72|
000016  f7fffffe          BL       GPIO_ResetBits
;;;120    		//nrf_delay_ms(1);
;;;121    		ucTmpVal <<= 1;	//最高位已经在数据线上了
00001a  0660              LSLS     r0,r4,#25
00001c  0e04              LSRS     r4,r0,#24
;;;122    		if(SPI_MISO_READ)	//
00001e  2140              MOVS     r1,#0x40
000020  4809              LDR      r0,|L2.72|
000022  f7fffffe          BL       GPIO_ReadInputDataBit
000026  b110              CBZ      r0,|L2.46|
;;;123    		{
;;;124    			ucTmpVal |= 0x01;
000028  f0440401          ORR      r4,r4,#1
00002c  e001              B        |L2.50|
                  |L2.46|
;;;125    		}
;;;126    		else
;;;127    		{
;;;128    			ucTmpVal &= 0xfe;
00002e  f00404fe          AND      r4,r4,#0xfe
                  |L2.50|
;;;129    		}
;;;130    		//dat <<= 1;注:此处最高位被移除了
;;;131    		SPI_CLK_HIGH;
000032  2120              MOVS     r1,#0x20
000034  4804              LDR      r0,|L2.72|
000036  f7fffffe          BL       GPIO_SetBits
00003a  1c68              ADDS     r0,r5,#1              ;117
00003c  b2c5              UXTB     r5,r0                 ;117
                  |L2.62|
00003e  2d08              CMP      r5,#8                 ;117
000040  dbe7              BLT      |L2.18|
;;;132    		//nrf_delay_ms(1);
;;;133    	}
;;;134    	
;;;135    	return ucTmpVal;
000042  4620              MOV      r0,r4
;;;136    }
000044  bd70              POP      {r4-r6,pc}
;;;137    #endif
                          ENDP

000046  0000              DCW      0x0000
                  |L2.72|
                          DCD      0x40010800

                          AREA ||i.Spi_WriteByte||, CODE, READONLY, ALIGN=2

                  Spi_WriteByte PROC
;;;79     #if _CPOL==0&&_CPHA==0  
;;;80     void Spi_WriteByte(uint8_t _ucByte)
000000  b570              PUSH     {r4-r6,lr}
;;;81     {
000002  4604              MOV      r4,r0
;;;82         uint8_t ucDataLen = 0;
000004  2500              MOVS     r5,#0
;;;83       
;;;84         for (ucDataLen = 0; ucDataLen < 8; ucDataLen++)
000006  bf00              NOP      
000008  e017              B        |L3.58|
                  |L3.10|
;;;85         {
;;;86             SPI_CLK_LOW;//时钟上升沿采样传输数据
00000a  2120              MOVS     r1,#0x20
00000c  480c              LDR      r0,|L3.64|
00000e  f7fffffe          BL       GPIO_ResetBits
;;;87     				//nrf_delay_ms(1);	//延时决定了SPI的CLK速率
;;;88             if(_ucByte & 0x80)	//发送数据
000012  f0040080          AND      r0,r4,#0x80
000016  b120              CBZ      r0,|L3.34|
;;;89     		{
;;;90     			SPI_MOSI_HIGH;
000018  2180              MOVS     r1,#0x80
00001a  4809              LDR      r0,|L3.64|
00001c  f7fffffe          BL       GPIO_SetBits
000020  e003              B        |L3.42|
                  |L3.34|
;;;91     		} 
;;;92             else
;;;93             {
;;;94     			SPI_MOSI_LOW;
000022  2180              MOVS     r1,#0x80
000024  4806              LDR      r0,|L3.64|
000026  f7fffffe          BL       GPIO_ResetBits
                  |L3.42|
;;;95     		}
;;;96             SPI_CLK_HIGH;
00002a  2120              MOVS     r1,#0x20
00002c  4804              LDR      r0,|L3.64|
00002e  f7fffffe          BL       GPIO_SetBits
;;;97     			//	nrf_delay_ms(1);	//延时决定了SPI的CLK速率
;;;98             _ucByte <<= 1;
000032  0660              LSLS     r0,r4,#25
000034  0e04              LSRS     r4,r0,#24
000036  1c68              ADDS     r0,r5,#1              ;84
000038  b2c5              UXTB     r5,r0                 ;84
                  |L3.58|
00003a  2d08              CMP      r5,#8                 ;84
00003c  dbe5              BLT      |L3.10|
;;;99         }
;;;100    }
00003e  bd70              POP      {r4-r6,pc}
;;;101    
                          ENDP

                  |L3.64|
                          DCD      0x40010800
