; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\drvadc.o --asm_dir=.\ --list_dir=.\ --depend=.\drvadc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\App\inc -I..\Driver\inc -I..\Libraries\CMSIS\Core\inc -I..\Libraries\CMSIS\Device\inc -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\HalIterface\inc -I..\User\inc -I..\Driver\src -ID:\KEIL_ARM_PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\keil_arm\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=533 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\drvadc.crf ..\Driver\src\drvadc.c]
                          THUMB

                          AREA ||i.Adc_Config||, CODE, READONLY, ALIGN=2

                  Adc_Config PROC
;;;48     //---------------------------------------------------------------------------------------------------------------------------------------------
;;;49     void  Adc_Config(void)
000000  b500              PUSH     {lr}
;;;50     { 	
000002  b085              SUB      sp,sp,#0x14
;;;51     	ADC_InitTypeDef ADC_InitStructure; 
;;;52     	
;;;53     	RCC_APB2PeriphClockCmd(RCC_PCLK_ADC_CHL, ENABLE );	  //使能ADC1通道时钟
000004  2101              MOVS     r1,#1
000006  0248              LSLS     r0,r1,#9
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;54     	RCC_ADCCLKConfig(RCC_PCLK2_Div6);   //设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M
00000c  f44f4000          MOV      r0,#0x8000
000010  f7fffffe          BL       RCC_ADCCLKConfig
;;;55     
;;;56     	ADC_DeInit(ADC_CHL);  //复位ADC1,将外设 ADC1 的全部寄存器重设为缺省值
000014  4816              LDR      r0,|L1.112|
000016  f7fffffe          BL       ADC_DeInit
;;;57     
;;;58     	ADC_InitStructure.ADC_Mode 					= ADC_Mode_Independent;	//ADC工作模式:ADC1和ADC2工作在独立模式
00001a  2000              MOVS     r0,#0
00001c  9000              STR      r0,[sp,#0]
;;;59     	ADC_InitStructure.ADC_ScanConvMode 			= DISABLE;	//模数转换工作在单通道模式
00001e  f88d0004          STRB     r0,[sp,#4]
;;;60     	ADC_InitStructure.ADC_ContinuousConvMode 	= DISABLE;	//模数转换工作在单次转换模式
000022  f88d0005          STRB     r0,[sp,#5]
;;;61     	ADC_InitStructure.ADC_ExternalTrigConv 		= ADC_ExternalTrigConv_None;	//转换由软件而不是外部触发启动
000026  f44f2060          MOV      r0,#0xe0000
00002a  9002              STR      r0,[sp,#8]
;;;62     	ADC_InitStructure.ADC_DataAlign 			= ADC_DataAlign_Right;	//ADC数据右对齐
00002c  2000              MOVS     r0,#0
00002e  9003              STR      r0,[sp,#0xc]
;;;63     	ADC_InitStructure.ADC_NbrOfChannel			= 1;	//顺序进行规则转换的ADC通道的数目
000030  2001              MOVS     r0,#1
000032  f88d0010          STRB     r0,[sp,#0x10]
;;;64     	ADC_Init(ADC_CHL, &ADC_InitStructure);	//根据ADC_InitStruct中指定的参数初始化外设ADCx的寄存器   
000036  4669              MOV      r1,sp
000038  480d              LDR      r0,|L1.112|
00003a  f7fffffe          BL       ADC_Init
;;;65     
;;;66     	ADC_Cmd(ADC_CHL, ENABLE);	//使能指定的ADC1
00003e  2101              MOVS     r1,#1
000040  480b              LDR      r0,|L1.112|
000042  f7fffffe          BL       ADC_Cmd
;;;67     	
;;;68     	ADC_ResetCalibration(ADC_CHL);	//使能复位校准  
000046  480a              LDR      r0,|L1.112|
000048  f7fffffe          BL       ADC_ResetCalibration
;;;69     	while(ADC_GetResetCalibrationStatus(ADC_CHL));	//等待复位校准结束
00004c  bf00              NOP      
                  |L1.78|
00004e  4808              LDR      r0,|L1.112|
000050  f7fffffe          BL       ADC_GetResetCalibrationStatus
000054  2800              CMP      r0,#0
000056  d1fa              BNE      |L1.78|
;;;70     	
;;;71     	ADC_StartCalibration(ADC_CHL);	 //开启AD校准
000058  4805              LDR      r0,|L1.112|
00005a  f7fffffe          BL       ADC_StartCalibration
;;;72     	while(ADC_GetCalibrationStatus(ADC_CHL));	 //等待校准结束
00005e  bf00              NOP      
                  |L1.96|
000060  4803              LDR      r0,|L1.112|
000062  f7fffffe          BL       ADC_GetCalibrationStatus
000066  2800              CMP      r0,#0
000068  d1fa              BNE      |L1.96|
;;;73      
;;;74     //	ADC_SoftwareStartConvCmd(ADC1, ENABLE);		//使能指定的ADC1的软件转换启动功能
;;;75     
;;;76     }
00006a  b005              ADD      sp,sp,#0x14
00006c  bd00              POP      {pc}
;;;77     
                          ENDP

00006e  0000              DCW      0x0000
                  |L1.112|
                          DCD      0x40012400

                          AREA ||i.Adc_GpioConfig||, CODE, READONLY, ALIGN=2

                  Adc_GpioConfig PROC
;;;27     //---------------------------------------------------------------------------------------------------------------------------------------------
;;;28     void Adc_GpioConfig(void)
000000  b508              PUSH     {r3,lr}
;;;29     {	
;;;30     	GPIO_InitTypeDef gpio_init;
;;;31     	
;;;32     	RCC_APB2PeriphClockCmd(RCC_PCLK_ADC_GPIO, ENABLE );	  //使能ADC1通道时钟
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;33     	
;;;34     	//PA1 作为模拟通道输入引脚                         
;;;35     	gpio_init.GPIO_Pin = ADC_IN_PIN;	//ADC输入引脚
00000a  2002              MOVS     r0,#2
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;36     	gpio_init.GPIO_Mode = GPIO_Mode_AIN;		//模拟输入引脚
000010  2000              MOVS     r0,#0
000012  f88d0003          STRB     r0,[sp,#3]
;;;37     	GPIO_Init(PORT_ADC_IN, &gpio_init);	
000016  4669              MOV      r1,sp
000018  4801              LDR      r0,|L2.32|
00001a  f7fffffe          BL       GPIO_Init
;;;38     }
00001e  bd08              POP      {r3,pc}
;;;39     
                          ENDP

                  |L2.32|
                          DCD      0x40010800

                          AREA ||i.Adc_Init||, CODE, READONLY, ALIGN=1

                  Adc_Init PROC
;;;86     //---------------------------------------------------------------------------------------------------------------------------------------------
;;;87     void Adc_Init(void)
000000  b510              PUSH     {r4,lr}
;;;88     {
;;;89     	Adc_GpioConfig();	//IO初始化
000002  f7fffffe          BL       Adc_GpioConfig
;;;90     	Adc_Config();	//ADC功能配置
000006  f7fffffe          BL       Adc_Config
;;;91     }
00000a  bd10              POP      {r4,pc}
;;;92     
                          ENDP


                          AREA ||i.Get_AdcAverage||, CODE, READONLY, ALIGN=1

                  Get_AdcAverage PROC
;;;123    //---------------------------------------------------------------------------------------------------------------------------------------------
;;;124    uint16_t Get_AdcAverage(uint8_t _ucChl, uint8_t _ucTimes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;125    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
;;;126    	uint32_t ulTmpVal = 0;
000008  2500              MOVS     r5,#0
;;;127    	uint8_t i = 0;
00000a  2600              MOVS     r6,#0
;;;128    	
;;;129    	for(i = 0; i < _ucTimes; i++)
00000c  bf00              NOP      
00000e  e008              B        |L4.34|
                  |L4.16|
;;;130    	{
;;;131    		ulTmpVal += Get_AdcConvertVal(_ucChl);
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       Get_AdcConvertVal
000016  4405              ADD      r5,r5,r0
;;;132    		delay_ms(5);
000018  2005              MOVS     r0,#5
00001a  f7fffffe          BL       delay_ms
00001e  1c70              ADDS     r0,r6,#1              ;129
000020  b2c6              UXTB     r6,r0                 ;129
                  |L4.34|
000022  42a6              CMP      r6,r4                 ;129
000024  dbf4              BLT      |L4.16|
;;;133    	}
;;;134    	return ulTmpVal / _ucTimes;
000026  fbb5f0f4          UDIV     r0,r5,r4
00002a  b280              UXTH     r0,r0
;;;135    } 	
00002c  e8bd81f0          POP      {r4-r8,pc}
;;;136    
                          ENDP


                          AREA ||i.Get_AdcConvertVal||, CODE, READONLY, ALIGN=2

                  Get_AdcConvertVal PROC
;;;101    //---------------------------------------------------------------------------------------------------------------------------------------------
;;;102    uint16_t Get_AdcConvertVal(uint8_t _ucChl)   
000000  b510              PUSH     {r4,lr}
;;;103    {
000002  4604              MOV      r4,r0
;;;104      	//设置指定ADC的规则组通道，一个序列，采样时间
;;;105    	ADC_RegularChannelConfig(ADC_CHL, _ucChl, 1, ADC_SampleTime_239Cycles5);	//ADC1,ADC通道,采样时间为239.5周期	  			    
000004  2307              MOVS     r3,#7
000006  2201              MOVS     r2,#1
000008  4621              MOV      r1,r4
00000a  4809              LDR      r0,|L5.48|
00000c  f7fffffe          BL       ADC_RegularChannelConfig
;;;106      
;;;107    	ADC_SoftwareStartConvCmd(ADC_CHL, ENABLE);		//使能指定的ADC1的软件转换启动功能	
000010  2101              MOVS     r1,#1
000012  4807              LDR      r0,|L5.48|
000014  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;108    	 
;;;109    	while(!ADC_GetFlagStatus(ADC_CHL, ADC_FLAG_EOC));	//等待转换结束
000018  bf00              NOP      
                  |L5.26|
00001a  2102              MOVS     r1,#2
00001c  4804              LDR      r0,|L5.48|
00001e  f7fffffe          BL       ADC_GetFlagStatus
000022  2800              CMP      r0,#0
000024  d0f9              BEQ      |L5.26|
;;;110    
;;;111    	return ADC_GetConversionValue(ADC_CHL);		//返回最近一次ADC1规则组的转换结果
000026  4802              LDR      r0,|L5.48|
000028  f7fffffe          BL       ADC_GetConversionValue
;;;112    }
00002c  bd10              POP      {r4,pc}
;;;113    
                          ENDP

00002e  0000              DCW      0x0000
                  |L5.48|
                          DCD      0x40012400
