; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\usart.o --asm_dir=.\ --list_dir=.\ --depend=.\usart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\App\inc -I..\Driver\inc -I..\Libraries\CMSIS\Core\inc -I..\Libraries\CMSIS\Device\inc -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\HalIterface\inc -I..\User\inc -I..\Driver\src -ID:\KEIL_ARM_PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\keil_arm\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=533 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\usart.crf ..\Driver\src\usart.c]
                          THUMB

                          AREA ||i.Usart_Init||, CODE, READONLY, ALIGN=1

                  Usart_Init PROC
;;;79       
;;;80     void Usart_Init(USART_TypeDef *UsartChal, uint32_t bound)
000000  4770              BX       lr
;;;81     {
;;;82     #if 1
;;;83     	//GPIO端口设置
;;;84     //	GPIO_InitTypeDef GPIO_InitStructure;
;;;85     //	USART_InitTypeDef USART_InitStructure;
;;;86     //	NVIC_InitTypeDef NVIC_InitStructure;
;;;87     	
;;;88     	if (UsartChal == USART1)
;;;89     	{
;;;90     //		RCC_APB2PeriphClockCmd(USART1_GPIO_CLK_ALLENABLE, ENABLE);	//使能USART1，GPIOA时钟
;;;91     
;;;92     //		//USART1_TXD   GPIOA.9
;;;93     //		GPIO_InitStructure.GPIO_Pin = USART1_TXD_IO; //PA.9
;;;94     //		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;95     //		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽输出
;;;96     //		GPIO_Init(USART1_TXD_PORT, &GPIO_InitStructure);//初始化GPIOA.9
;;;97     
;;;98     //		//USART1_RXD	  GPIOA.10初始化
;;;99     //		GPIO_InitStructure.GPIO_Pin = USART1_RXD_IO;//PA10
;;;100    //		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
;;;101    //		GPIO_Init(USART1_RXD_PORT, &GPIO_InitStructure);//初始化GPIOA.10  
;;;102    
;;;103    		//Usart1 NVIC 配置
;;;104    //		NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
;;;105    //		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3 ;//抢占优先级3
;;;106    //		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;		//子优先级3
;;;107    //		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
;;;108    //		NVIC_Init(&NVIC_InitStructure);	//根据指定的参数初始化VIC寄存器
;;;109    
;;;110    //		//USART 初始化设置
;;;111    //		USART_InitStructure.USART_BaudRate = bound;//串口波特率
;;;112    //		USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
;;;113    //		USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
;;;114    //		USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位
;;;115    //		USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
;;;116    //		USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
;;;117    
;;;118    //		USART_Init(UsartChal, &USART_InitStructure); //初始化串口1
;;;119    //		USART_ITConfig(UsartChal, USART_IT_RXNE, ENABLE);//开启串口接受中断
;;;120    //		USART_Cmd(UsartChal, ENABLE); 		//使能串口1 
;;;121    	}
;;;122    	 
;;;123    #endif	                   
;;;124    
;;;125    }
;;;126    
                          ENDP


                          AREA ||i.Usart_SendSomeBytes||, CODE, READONLY, ALIGN=1

                  Usart_SendSomeBytes PROC
;;;126    
;;;127    void Usart_SendSomeBytes(USART_TypeDef *UsartChal, uint8_t *pBuffer, uint16_t Len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;128    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;129    	uint16_t i = 0;
00000a  2400              MOVS     r4,#0
;;;130    	
;;;131    	for (i = 0; i < Len; i++)
00000c  bf00              NOP      
00000e  e00c              B        |L2.42|
                  |L2.16|
;;;132    	{
;;;133    		while(USART_GetFlagStatus(UsartChal, USART_FLAG_TC) == RESET)
000010  e003              B        |L2.26|
                  |L2.18|
;;;134    		{
;;;135    			USART_SendData(UsartChal, pBuffer[i]);
000012  5d29              LDRB     r1,[r5,r4]
000014  4638              MOV      r0,r7
000016  f7fffffe          BL       USART_SendData
                  |L2.26|
00001a  2140              MOVS     r1,#0x40              ;133
00001c  4638              MOV      r0,r7                 ;133
00001e  f7fffffe          BL       USART_GetFlagStatus
000022  2800              CMP      r0,#0                 ;133
000024  d0f5              BEQ      |L2.18|
000026  1c60              ADDS     r0,r4,#1              ;131
000028  b284              UXTH     r4,r0                 ;131
                  |L2.42|
00002a  42b4              CMP      r4,r6                 ;131
00002c  dbf0              BLT      |L2.16|
;;;136    		}
;;;137    	}
;;;138    }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;139    
                          ENDP


                          AREA ||i._sys_exit||, CODE, READONLY, ALIGN=1

                  _sys_exit PROC
;;;51     //定义_sys_exit()以避免使用半主机模式    
;;;52     void _sys_exit(int x) 
000000  bf00              NOP      
;;;53     { 
;;;54     	x = x; 
;;;55     } 
000002  4770              BX       lr
;;;56     //重定义fputc函数 
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  USART_RX_BUF
                          %        200

                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000
                  USART_RX_STA
000004  0000              DCW      0x0000
